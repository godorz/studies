# 算法-二分查找
> [Problems](#problems)

- [Python 中的二分查找](#python-中的二分查找)
- [二分查找的本质](#二分查找的本质)
    - [示例](#示例)
    - [性质](#性质)
    - [踩坑记录](#踩坑记录)

## Python 中的二分查找

<summary><b>问题简述</b></summary>

```txt
实现 Python 中的二分查找：
    def bisect_left(a, x, lo=0, hi=None) -> int
    def bisect_right(a, x, lo=0, hi=None) -> int
```

<summary><b>返回值的含义</b></summary>

- 返回值的含义：对给定有序数组 `a` 和目标值 `x`，把 `x` 插入 `a` 中的索引；
- `*_left` 和 `*_right` 的区别：
    - 当 `a` 中不存在 `x` 时，两者返回值相同；
    - 当 `a` 中存在 `x` 时，`*_left` 返回 x 应该插入的最左边位置，`*_right` 返回最右边位置；
        ```python
        # 示例：ls = [1,2,2,3,4], x = 2，记下划线位置为插入位置
        bisect_left(a, 2)  # 返回 1，即 [1,_,2,2,3,4]
        bisect_right(a, 2) # 返回 3，即 [1,2,2,_,3,4]
        ```

<!-- <div align="center"><img src="../../../_assets/xxx.png" height="300" /></div> -->

<details><summary><b>Python：<code>bisect_left</code></b></summary>

```python
def bisect_left(a, x, lo=0, hi=None):
    if hi is None:
        hi = len(a)  # 注意查找范围是一个左闭右开区间 [lo, hi)
    
    # assert lo >= 0 and hi <= len(a)

    l, r = lo, hi
    while l < r:  # 退出循环时 l == r
        m = (l + r) // 2
        if a[m] < x:
            l = m + 1
        else:
            r = m
    return l
```

</details>


<details><summary><b>Python：<code>bisect_right</code></b></summary>

```python
def bisect_right(a, x, lo=0, hi=None):
    if hi is None:
        hi = len(a)  # 注意查找范围是一个左闭右开区间 [lo, hi)
    
    # assert lo >= 0 and hi <= len(a)

    l, r = lo, hi
    while l < r:  # 退出循环时 l == r
        m = (l + r) // 2
        if a[m] <= x:  #  与 bisect_left 的唯一区别
            l = m + 1
        else:
            r = m
    return l
```

</details>


## 二分查找的本质

- **“二分”的本质**：通过某一**分界点**，能将**搜索范围**划分成两个部分，且可以通过**一组互斥的条件**确定目标值所在的区域，从而排除另一个区域，达到快速查找的目的；
    - 如果是一维数组，那么分界点一般是中点；
- **单调性**不是二分查找的必要条件；

### 示例
**有序数组查找指定值**（最常见的场景）
- **分界点**：中点
- **互斥条件**：如果目标值大于中点值，则目标值必在右侧，小于必在左侧；

**非单调的二分查找**（特殊场景）
```text
给定一个长度为n的数组，左边全是奇数，右边全是偶数，求最后一个奇数的索引（保证第一个数字一定是奇数）
示例：
    输入：[3, 5, 1, 7, 11, 9, 2, 4, 10, 6, 8]
    输出：5
```
- **分界点**：中点
- **互斥条件**：如果中点值两侧同奇，在目标值必在右侧，同偶必在左侧；


### 性质
- 对于中点值 `mid = low + (high - low) >> 1`，恒有 `low <= mid < high`

### 踩坑记录

- `mid = l + (r - l) >> 1` 求中值的写法在 C++ 中 OK，但是在 Python 中是有问题的，因为在 Python 中 `>>` 的优先级低于 `+`，所以这样求出来的实际上是 `(l + r - l) >> 1`；因此Python3 中正确的写法应该是 `mid = l + (r - l) // 2`，而因为 Python 不存在溢出，其实 `(l + r) // 2` 就可以了；

<!-- Auto-generated -->

## Problems <!-- omit in toc --> 
- [`LeetCode_0004_困难_寻找两个正序数组的中位数`](../problems/2022/02/LeetCode_0004_困难_寻找两个正序数组的中位数.md)
- [`LeetCode_0029_中等_两数相除`](../problems/2021/10/LeetCode_0029_中等_两数相除.md)
- [`LeetCode_0033_中等_搜索旋转排序数组`](../problems/2021/10/LeetCode_0033_中等_搜索旋转排序数组.md)
- [`LeetCode_0240_中等_搜索二维矩阵2`](../problems/2021/10/LeetCode_0240_中等_搜索二维矩阵2.md)
- [`LeetCode_0352_困难_将数据流变为多个不相交区间`](../problems/2021/10/LeetCode_0352_困难_将数据流变为多个不相交区间.md)
- [`LeetCode_0441_简单_排列硬币`](../problems/2021/10/LeetCode_0441_简单_排列硬币.md)
- [`剑指Offer2_001_中等_整数除法`](../problems/2022/02/剑指Offer2_001_中等_整数除法.md)
- [`剑指Offer2_069_简单_山峰数组的顶部`](../problems/2022/02/剑指Offer2_069_简单_山峰数组的顶部.md)
- [`剑指Offer_0400_中等_二维数组中的查找`](../problems/2021/11/剑指Offer_0400_中等_二维数组中的查找.md)
- [`剑指Offer_1100_简单_旋转数组的最小数字`](../problems/2021/11/剑指Offer_1100_简单_旋转数组的最小数字.md)
- [`剑指Offer_1600_中等_数值的整数次方（快速幂）`](../problems/2021/11/剑指Offer_1600_中等_数值的整数次方（快速幂）.md)
- [`剑指Offer_5301_简单_求0～n-1中缺失的数字`](../problems/2022/01/剑指Offer_5301_简单_求0～n-1中缺失的数字.md)
- [`剑指Offer_5302_简单_在排序数组中查找数字`](../problems/2022/01/剑指Offer_5302_简单_在排序数组中查找数字.md)
- [`牛客_0029_中等_二维数组中的查找`](../problems/2022/02/牛客_0029_中等_二维数组中的查找.md)
- [`牛客_0032_简单_求平方根`](../problems/2022/02/牛客_0032_简单_求平方根.md)
- [`牛客_0036_较难_在两个长度相等的排序数组中找到上中位数`](../problems/2022/02/牛客_0036_较难_在两个长度相等的排序数组中找到上中位数.md)
- [`牛客_0048_简单_在旋转过的有序数组中寻找目标值`](../problems/2022/03/牛客_0048_简单_在旋转过的有序数组中寻找目标值.md)
- [`牛客_0071_简单_旋转数组的最小数字`](../problems/2022/03/牛客_0071_简单_旋转数组的最小数字.md)
- [`牛客_0074_简单_数字在升序数组中出现的次数`](../problems/2022/03/牛客_0074_简单_数字在升序数组中出现的次数.md)
- [`牛客_0086_中等_矩阵元素查找`](../problems/2022/03/牛客_0086_中等_矩阵元素查找.md)
- [`牛客_0105_中等_二分查找-II`](../problems/2022/04/牛客_0105_中等_二分查找-II.md)