# 从暴力递归到动态规划

<!-- Tag: DFS2DP -->

> 笔记：[**从暴力递归到动态规划**](../../notes/算法/动态规划/从暴力递归到动态规划)

Problems
---
- [`LeetCode 0091 解码方法 (中等, 2022-02)`](#leetcode-0091-解码方法-中等-2022-02)
- [`剑指Offer 6000 n个骰子的点数 (中等, 2022-01)`](#剑指offer-6000-n个骰子的点数-中等-2022-01)
- [`牛客 0145 01背包 (中等, 2022-02)`](#牛客-0145-01背包-中等-2022-02)

---

### `LeetCode 0091 解码方法 (中等, 2022-02)`

[![DP](https://img.shields.io/badge/DP-lightgray.svg)](算法-动态规划(记忆化搜索)、递推.md)
[![DFS2DP](https://img.shields.io/badge/DFS2DP-lightgray.svg)](技巧-从暴力递归到动态规划.md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["DP", "DFS2DP"],
    "来源": "LeetCode",
    "难度": "中等",
    "编号": "0091",
    "标题": "解码方法",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
将数字解码成字母，返回可能的解码方法数；
例如，"11106" 可以映射为：
    "AAJF" ，将消息分组为 (1 1 10 6)
    "KJF" ，将消息分组为 (11 10 6)
```
> [91. 解码方法 - 力扣（LeetCode）](https://leetcode-cn.com/problems/decode-ways/)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：从左往右的暴力递归</b></summary>

- 定义 `dfs(i)` 表示 `s[:i]` 已经固定的情况下，`s[i:]` 的解码方法；
- 【递归基】`i=n` 时，`s[:n]` 都固定了，即表示找到了一种解法方法；
- 本题的难点是 `dfs(i)` 不光可以从 `dfs(i-1)` 递推，还可以从 `dfs(i-2)` 递推；
    > 可以看做是有限制的跳台阶问题；

<details><summary><b>Python</b></summary>

```python
class Solution:
    def numDecodings(self, s: str) -> int:

        from functools import lru_cache  # 记忆化搜索

        n = len(s)  # 字符长度

        @lru_cache(maxsize=None)
        def dfs(i):  # 表示 s[:i] 已经固定的情况下，s[i:] 的解码方法
            if i == n:  # s[:n] 都已经固定，即找到了一种有效的解码方法
                ret = 1
            elif s[i] == '0':  # 以 0 开始的字符不存在有效解码
                ret = 0
            elif s[i] == '1':  # 如果以 1 开头，可以尝试两个位置
                ret = dfs(i + 1)  # 这个 1 已经固定了
                if i + 1 < n:  # 因为 10 ~ 19 都存在有效解码，因此只要后面存在两个字符，就可以加上 dfs(i + 2)
                    ret += dfs(i + 2)
            elif s[i] == '2':  # 如果以 2 开头，可以有条件的尝试两个位置
                ret = dfs(i + 1)
                if i + 1 < n and '0' <= s[i + 1] <= '6':
                    ret += dfs(i + 2)
            else:  # 如果以 3~9 开头，只能尝试一个位置
                ret = dfs(i + 1)

            return ret

        return dfs(0)
```

</details>


<summary><b>思路2：将暴力递归转化为动态规划</b></summary>

- 有了递归过程后，就可以脱离原问题，模板化的将其转化为动态规划。

<details><summary><b>Python</b></summary>

```python
class Solution:
    def numDecodings(self, s: str) -> int:

        n = len(s)  # 字符长度
        dp = [0] * (n + 1)

        # 初始化（对应递归中的 base case）
        #   i == n 时 ret = 1，即
        dp[n] = 1

        # 递推过程：对应递归过程填空
        #   下面的写法略有冗余，可以做一些合并，但是为了做到跟递归一一对应，就没有修改
        for i in range(n - 1, -1, -1):
            # 为什么是倒序遍历，一方面可以从问题理解；
            #   另一方面可以从递归过程看，因为最后返回的是 dp[0]，同时 dp[i] 需要从  dp[i + 1] 递推，所以显然需要逆序遍历
            if s[i] == '0':
                dp[i] = 0  # ret = 0
            elif s[i] == '1':
                dp[i] = dp[i + 1]  # ret = rec(i + 1)
                if i + 1 < n:
                    dp[i] += dp[i + 2]  # ret += rec(i + 2)
            elif s[i] == '2':
                dp[i] = dp[i + 1]  # ret = rec(i + 1)
                if i + 1 < n and '0' <= s[i + 1] <= '6':
                    dp[i] += dp[i + 2]  # ret += rec(i + 2)
            else:
                dp[i] = dp[i + 1]  # ret = rec(i + 1)

        return dp[0]  # return rec(0)
```

</details>

---

### `剑指Offer 6000 n个骰子的点数 (中等, 2022-01)`

[![动态规划](https://img.shields.io/badge/动态规划-lightgray.svg)](算法-动态规划(记忆化搜索)、递推.md)
[![DFS2DP](https://img.shields.io/badge/DFS2DP-lightgray.svg)](技巧-从暴力递归到动态规划.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["动态规划", "DFS2DP"],
    "来源": "剑指Offer",
    "编号": "6000",
    "难度": "中等",
    "标题": "n个骰子的点数"
}-->

<summary><b>问题简述</b></summary>

```txt
把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。
输入 n，打印出 s 的所有可能的值出现的概率（按 s 从小到大排列）。
```

<details><summary><b>详细描述</b></summary>

```txt
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

示例 1:
    输入: 1
    输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
示例 2:
    输入: 2
    输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]

限制：
    1 <= n <= 11

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：从暴力递归到动态规划</b></summary>

- 定义 `dfs(k)` 返回 k 个骰子产生的可能性序列 `dp`，其中 `dp[i]` 表示 k 个骰子掷出点数 i 的可能数；
- 【递归基】`k=1` 时，`dfs(1)` 返回 `dp = [_, 1, 1, 1, 1, 1, 1]`（为方便编码，`dp[:n]` 为占位符，无实际意义）
- 递归过程即使用 `dfs(k-1)` 返回的 `dp_pre` 生成 `dfs(k)` 的 `dp`；
- 然后根据暴力递归过程直接写出动态规划的代码（已经与原问题解耦）；

<details><summary><b>Python：暴力递归</b></summary>

```python
class Solution:
    def dicesProbability(self, n: int) -> List[float]:

        def dfs(k):
            if k == 1:
                return [1] * 7

            dp_pre = dfs(k - 1)
            dp = [0] * (k * 6 + 1)

            # 遍历方式 1:
            # for i in range(1 * (n - 1), 6 * (n - 1) + 1):  # n - 1 个骰子的点数范围
            #     for d in range(1, 7):  # 当前骰子掷出的点数
            #         dp[i + d] += dp_pre[i]

            # 遍历方式 2（推荐，不需要判断范围）：
            for i in range(1 * k, 6 * k + 1):  # n 个骰子的点数范围
                for d in range(1, 7):  # 当前骰子掷出的点数
                    if 1 * (k - 1) <= i - d <= 6 * (k - 1):
                        dp[i] += dp_pre[i - d]

            return dp

        dp = dfs(n)
        return [x / (6 ** n) for x in dp[n:]]
```

</details>

<details><summary><b>Python：动态规划</b></summary>

```python
class Solution:
    def dicesProbability(self, n: int) -> List[float]:
        

        dp = [1] * 7

        for k in range(2, n + 1):
            dp_pre = dp
            dp = [0] * (k * 6 + 1)
            for i in range(1 * k, 6 * k + 1):  # n 个骰子的点数范围
                for d in range(1, 7):  # 当前骰子掷出的点数
                    if 1 * (k - 1) <= i - d <= 6 * (k - 1):
                        dp[i] += dp_pre[i - d]

        return [x / (6 ** n) for x in dp[n:]]
```

</details>


<summary><b>思路2：从“跳台阶”理解本题</b></summary>

- “跳台阶”的递推公式为：`dp[i] = dp[i-1] + dp[i-2]`；
- 在本题中，可以看做目标台阶数为 `i`，每次可以跳 `1~6` 步；对 `k` 个骰子，`i` 的范围为 `k ~ 6*k`，每次都是从 `n-1` 个骰子的可能性出发；
- 因此本题的递推公式为：`dp[k][i] = dp[k-1][i-1] + dp[k-1][i-2] + .. + dp[k-1][i-6]`；
    - 同时因为每一轮只和上一轮相关，可以使用两个数组滚动优化空间；
        > 也可以只是用一个数组，参考：[n个骰子的点数 - 路漫漫我不畏](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/nge-tou-zi-de-dian-shu-dong-tai-gui-hua-ji-qi-yo-3/)
- 代码同上。

---

### `牛客 0145 01背包 (中等, 2022-02)`

[![DP](https://img.shields.io/badge/DP-lightgray.svg)](算法-动态规划(记忆化搜索)、递推.md)
[![DFS2DP](https://img.shields.io/badge/DFS2DP-lightgray.svg)](技巧-从暴力递归到动态规划.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["DP", "DFS2DP"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0145",
    "标题": "01背包",
    "公司": ["阿里"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定最多能容纳 V 体积的背包，和 n 个物品，每个物品有重量(w)和体积(v)两个属性；
求背包能放的最大重量；
每个物品的重量(w)和体积(v)保存在数组 vw 中；

示例1：
    输入：10,2,[[1,3],[10,4]]
    返回：4
示例2：
    输入：10,2,[[1,3],[9,8]]
    返回：11
```
> [01背包_牛客题霸_牛客网](https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：单向暴力递归</b></summary>

- 本题“从左往右”和“从右往左”没有区别，因为不存在依赖关系——你从左边开始取物品和从右边开始没有区别；

<details><summary><b>Python：写法1）从左往右</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self , V: int, n: int, vw: List[List[int]]) -> int:
        # write code here
        
        # 函数定义：从第 i 个物品开始取，剩余容量为 rest 的情况下，能得到的最大重量
        def recur(i, rest):
            if i == n:  # 因为下标从 0 开始，所以 i == n 表示当期已经没有物品可以取，因此最大重量为 0
                ret = 0
            elif rest < vw[i][0]:  # 如果剩余容量不足以放下当期物品，只能跳过在从下一个物品开始
                ret = recur(i + 1, rest)
            else:  # 如果能取当前物品，根据取与不取当前物品，返回其中的最大值
                ret = max(recur(i + 1, rest), recur(i + 1, rest - vw[i][0]) + vw[i][1])
            return ret

        return recur(0, V)
```

</details>

<details><summary><b>Python：写法2）从右往左（本题没有区别，均可）</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self , V: int, n: int, vw: List[List[int]]) -> int:
        # write code here
        
        # 函数定义：从第 i 个物品开始取，剩余容量为 rest 的情况下，能得到的最大重量
        def recur(i, rest):
            if i == 0:  # 因为下标从 n-1 开始，所以 i == 0 表示当期已经没有物品可以取，因此最大重量为 0
                ret = 0
            elif rest < vw[i][0]:  # 如果剩余容量不足以放下当期物品，只能跳过在从下一个物品开始
                ret = recur(i - 1, rest)
            else:  # 如果能取当前物品，根据取与不取当前物品，返回其中的最大值
                ret = max(recur(i - 1, rest), recur(i - 1, rest - vw[i][0]) + vw[i][1])
            return ret

        return recur(n - 1, V)
```

</details>


<summary><b>思路2：在递归过程中加入记忆化搜索</b></summary>

<details><summary><b>Python：从左往右</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self , V: int, n: int, vw: List[List[int]]) -> int:
        # write code here
        import sys
        sys.setrecursionlimit(1010)  # 解除递归深度限制
        
        dp = dict()
        
        def recur(i, rest):
            if (i, rest) in dp:
                return dp[(i, rest)]
            
            if i == n:
                ret = 0
            elif rest < vw[i][0]:
                ret = recur(i + 1, rest)
            else:
                ret = max(recur(i + 1, rest), recur(i + 1, rest - vw[i][0]) + vw[i][1])
            dp[(i, rest)] = ret
            return ret

        return recur(0, V)
```

</details>


<details><summary><b>Python：使用标准库提供的缓存方法</b></summary>

- 不知道什么原因无法通过全部用例，好像 `lru_cache` 和 `setrecursionlimit` 不能同时生效；

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self , V: int, n: int, vw: List[List[int]]) -> int:
        # write code here
        import sys
        sys.setrecursionlimit(1010)  # 解除递归深度限制

        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def recur(i, rest):
            if i == n:
                ret = 0
            elif rest < vw[i][0]:
                ret = recur(i + 1, rest)
            else:
                ret = max(recur(i + 1, rest), recur(i + 1, rest - vw[i][0]) + vw[i][1])
            return ret

        return recur(0, V)
```

</details>


<summary><b>思路3：将暴力递归转化为动态规划</b></summary>

<details><summary><b>Python：从左往右</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self, V: int, n: int, vw: List[List[int]]) -> int:
        # write code here

        # dp = dict()
        dp = [[0] * (V + 1) for _ in range(n + 1)]

        # 第 0 步，从递归的返回看 dp 的返回
        #   从左往右中，返回的是 recue(0, V)，对应就是 dp[0][V]
        #   从右往左中，返回的是 recue(n - 1, V)，对应就是 dp[n - 1][V]
        # 通过这一步提前判断遍历方向

        # 第 1 步：dp初始化，对应递归中的 base case
        #   因为申请 dp 的时候已经初始化为 0 了，所以这里可以省略
        # for j in range(V + 1):
        #     dp[n][j] = 0

        # 第 2 步，把递归过程一一对应到 dp 位置即可
        #   因为初始化把 i == n 的情况都填完了，所以 i 从 n-1 开始
        for i in range(n - 1, -1, -1):
            # 因为本题只有行依赖，没有列依赖，所以对 V 的遍历顺序没有要求
            #   什么意思呢？就是你在递归的时候走 rest < vw[i][0] 分支和 rest >= vw[i][0] 分支的时候没有顺序要求，先判断哪个都可以
            #   应用到这里就是以下两种遍历方向都可以
            # for rest in range(V, -1, -1):  # 相当于先判断 rest >= vw[i][0]
            for rest in range(1, V + 1):  # 相当于先判断 rest < vw[i][0]
                if rest < vw[i][0]:
                    # ret = recur(i + 1, rest)
                    dp[i][rest] = dp[i + 1][rest]
                else:
                    # ret = max(recur(i + 1, rest), vw[i][1] + recur(i + 1, rest - vw[i][0]))
                    dp[i][rest] = max(dp[i + 1][rest], dp[i + 1][rest - vw[i][0]] + vw[i][1])

        # return recur(0, V)
        return dp[0][V]
```

</details>

---
