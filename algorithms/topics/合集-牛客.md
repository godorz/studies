# 牛客

<!-- Tag: 牛客 -->

Problems
---
- [`牛客 0001 大数加法 (中等, 2022-01)`](#牛客-0001-大数加法-中等-2022-01)
- [`牛客 0002 重排链表 (中等, 2022-01)`](#牛客-0002-重排链表-中等-2022-01)
- [`牛客 0003 链表中环的入口结点 (简单, 2022-01)`](#牛客-0003-链表中环的入口结点-简单-2022-01)
- [`牛客 0004 判断链表中是否有环 (简单, 2022-01)`](#牛客-0004-判断链表中是否有环-简单-2022-01)
- [`牛客 0005 二叉树根节点到叶子节点的所有路径和 (中等, 2022-01)`](#牛客-0005-二叉树根节点到叶子节点的所有路径和-中等-2022-01)
- [`牛客 0006 二叉树中的最大路径和 (困难, 2022-01)`](#牛客-0006-二叉树中的最大路径和-困难-2022-01)
- [`牛客 0007 买卖股票的最好时机(一) (简单, 2022-01)`](#牛客-0007-买卖股票的最好时机一-简单-2022-01)
- [`牛客 0008 二叉树中和为某一值的路径(二) (中等, 2022-01)`](#牛客-0008-二叉树中和为某一值的路径二-中等-2022-01)
- [`牛客 0009 二叉树中和为某一值的路径(一) (简单, 2022-01)`](#牛客-0009-二叉树中和为某一值的路径一-简单-2022-01)
- [`牛客 0010 大数乘法 (中等, 2022-01)`](#牛客-0010-大数乘法-中等-2022-01)
- [`牛客 0011 将升序数组转化为平衡二叉搜索树 (简单, 2022-01)`](#牛客-0011-将升序数组转化为平衡二叉搜索树-简单-2022-01)
- [`牛客 0012 重建二叉树 (中等, 2022-01)`](#牛客-0012-重建二叉树-中等-2022-01)
- [`牛客 0013 二叉树的最大深度 (简单, 2022-01)`](#牛客-0013-二叉树的最大深度-简单-2022-01)
- [`牛客 0014 按之字形顺序打印二叉树 (中等, 2022-01)`](#牛客-0014-按之字形顺序打印二叉树-中等-2022-01)
- [`牛客 0015 求二叉树的层序遍历 (中等, 2022-01)`](#牛客-0015-求二叉树的层序遍历-中等-2022-01)
- [`牛客 0016 对称的二叉树 (简单, 2022-01)`](#牛客-0016-对称的二叉树-简单-2022-01)
- [`牛客 0017 最长回文子串 (中等, 2022-01)`](#牛客-0017-最长回文子串-中等-2022-01)
- [`牛客 0018 顺时针旋转矩阵 (简单, 2022-01)`](#牛客-0018-顺时针旋转矩阵-简单-2022-01)
- [`牛客 0019 连续子数组的最大和 (简单, 2022-01)`](#牛客-0019-连续子数组的最大和-简单-2022-01)
- [`牛客 0020 数字字符串转化成IP地址 (中等, 2022-01)`](#牛客-0020-数字字符串转化成ip地址-中等-2022-01)
- [`牛客 0021 链表内指定区间反转 (中等, 2022-01)`](#牛客-0021-链表内指定区间反转-中等-2022-01)
- [`牛客 0022 合并两个有序的数组 (中等, 2022-01)`](#牛客-0022-合并两个有序的数组-中等-2022-01)
- [`牛客 0023 划分链表 (中等, 2022-01)`](#牛客-0023-划分链表-中等-2022-01)
- [`牛客 0091 最长上升子序列(三) (困难, 2022-02)`](#牛客-0091-最长上升子序列三-困难-2022-02)
- [`牛客 0145 01背包 (中等, 2022-02)`](#牛客-0145-01背包-中等-2022-02)

---

### `牛客 0001 大数加法 (中等, 2022-01)`

[![字符串](https://img.shields.io/badge/字符串-lightgray.svg)](数据结构-字符串.md)
[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["字符串", "模拟"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0001",
    "标题": "大数加法",
    "公司": ["百度", "阿里", "字节", "虾皮"]
}-->

<summary><b>问题简述</b></summary>

```txt
以字符串的形式读入两个数字，计算它们的和，以字符串形式返回。
```
> [大数加法_牛客题霸_牛客网](https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475)

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 把较短的字符串通过补前缀 0 使长度一致，此时只要处理好进位即可；

<details><summary><b>Python</b></summary>

```python
class Solution:
    def solve(self , s: str, t: str) -> str:
        # write code here
        n, m = len(s), len(t)
        if n < m:  # 确保 n >= m
            s, t = t, s
            n, m = m, n
            
        t = '0' * (n - m) + t  # 补0
        
        ret = ''
        ex = 0  # 进位标志
        for i in range(n - 1, -1, -1):
            r = int(s[i]) + int(t[i]) + ex
            ret = str(r % 10) + ret
            ex = r // 10
            
        if ex:
            ret = '1' + ret
        
        return ret
```

</details>

---

### `牛客 0002 重排链表 (中等, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["链表"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0002",
    "标题": "重排链表",
    "公司": ["美团", "字节", "快手"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定一个单链表 L 的头节点 head ，单链表 L 表示为：
    L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：
    L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
```
> [重排链表_牛客题霸_牛客网](https://www.nowcoder.com/practice/3d281dc0b3704347846a110bf561ef6b)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
 -->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：模拟</b></summary>

1. 先找到中间节点 mid；
2. 将链表 mid 反转；
3. 然后合并 head 和 mid；

<details><summary><b>Python</b></summary>

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head: return
    
        def  get_mid(p):
            lp, fp = p, p

            while fp and fp.next:
                lp = lp.next
                fp = fp.next.next
            
            return lp
        
        def reverse(p):
            cur, pre = p, None
            while cur:
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
            
            return pre
        
        mid = get_mid(head)  # 注意此时还没有断开两个链表
        mid = reverse(mid)

        # merge
        l, r = head, mid
        while True:
            l_nxt, r_nxt = l.next, r.next
            if not r_nxt:  # 这是一种写法，另一种写法是在获得 mid 后将 mid 与原链表断开（后移一个节点，结果也是正确的，见写法2）
                break
            l.next, r.next = r, l_nxt
            l, r = l_nxt, r_nxt
```

</details>

---

### `牛客 0003 链表中环的入口结点 (简单, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![快慢指针](https://img.shields.io/badge/快慢指针-lightgray.svg)](技巧-双指针-快慢指针.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["链表", "快慢指针"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0003",
    "标题": "链表中环的入口结点",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给一个长度为 n 的链表，若其中包含环，请找出该链表的环的入口结点，否则返回null。
```
> [链表中环的入口结点_牛客题霸_牛客网](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：快慢指针</b></summary>

- 快指针 `fast` 每次走两步，慢指针 `slow` 每次走一步；
- 若存在环，则 `fast` 与 `slow` 必会相遇；
- 相遇后，将 `slow` 重新指向 `pHead`，然后，双指针正常每次走一步；
- 当再次相遇时，即为入口节点；
- 注意无环的情况；

**证明**：
- 假设存在环，记环之前的节点数即为 $a$（不包括入口节点），环的节点数为 $b$；当 `fast` 和 `slow` 相遇时距离环入口的步数为 $c$；
- 下面证明：$a=c$
- 记 `fast` 和 `slow` 走的步数分别为 $f$ 和 $s$，且 $f-s = n*b$，即 `fast` 比 `slow` 多走了 `n` 圈；又 $f=2s$，可得 $s=n*b$，而实际上 `slow` 走的距离 $s=a + (n-1)b + (b-c)$，联立得 $a=c$；
- 因此当 `fast` 和 `slow` 在环内相遇时，将 `slow` 重新指向 `pHead`，然后双指针再次相遇时即为入口节点（每次走一步）；

<details><summary><b>Python</b></summary>

```python
class Solution:
    def EntryNodeOfLoop(self, pHead: ListNode):
        # write code here

        no_cycle = True
        slow = fast = pHead
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                no_cycle = False
                break

        if no_cycle:
            return None

        slow = pHead
        while slow != fast:
            slow = slow.next
            fast = fast.next

        return slow
```

</details>

---

### `牛客 0004 判断链表中是否有环 (简单, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![快慢指针](https://img.shields.io/badge/快慢指针-lightgray.svg)](技巧-双指针-快慢指针.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["链表", "快慢指针"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0004",
    "标题": "判断链表中是否有环",
    "公司": ["百度", "阿里", "小米"]
}-->

<summary><b>问题简述</b></summary>

```txt
判断给定的链表中是否有环。
```
> [判断链表中是否有环_牛客题霸_牛客网](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：快慢指针</b></summary>

<details><summary><b>Python</b></summary>

```python
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# @param head ListNode类 
# @return bool布尔型
#
class Solution:
    def hasCycle(self , head: ListNode) -> bool:
        
        fast = slow = head
        has_cycle = False
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                has_cycle = True
                break
        
        return has_cycle
```

</details>

---

### `牛客 0005 二叉树根节点到叶子节点的所有路径和 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0005",
    "标题": "二叉树根节点到叶子节点的所有路径和",
    "公司": ["小米", "快手", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树，求所有路径和，路径定义如下：
假设某条路径的从根节点到叶节点的值为 1->2->3，则记该条路径表示的值为 123；
输入确保每个节点的值在 0~9 之间；

示例
    1
   2 3
结果：25（12+13=25）
```
> [二叉树根节点到叶子节点的所有路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/185a87cd29eb42049132aed873273e83)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def sumNumbers(self , root: TreeNode) -> int:
        # write code here
        
        self.ret = 0
        
        def dfs(node: TreeNode, sum_):
            if not node:
                # self.ret += sum_  # 放在这里会导致“加两次”
                return
            
            sum_ = sum_ * 10 + node.val
            if not node.left and not node.right:
                self.ret += sum_
                return
            
            if node.left:
                dfs(node.left, sum_)
            if node.right:
                dfs(node.right, sum_)
        
        dfs(root, 0)
        return self.ret
```

</details>

---

### `牛客 0006 二叉树中的最大路径和 (困难, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "困难",
    "编号": "0006",
    "标题": "二叉树中的最大路径和",
    "公司": ["字节", "美团", "百度"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定二叉树中的最大路径和。
路径定义：
    1. 同一个节点在路径中最多出现一次；
    2. 路径至少包含一个节点，可以不经过根节点；
```
> [二叉树中的最大路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

- 定义函数 `maxGain(node)` 表示以 `node` 为**起点**的最大路径；显然 maxGain 可以通过递归计算（详见代码）；
- 则**经过** `node` 的最大路径和，可以表示为 `node.val + maxGain(node.left), maxGain(node.right)`；因此可以在计算 `maxGain(root)` 的过程中，记录经过每个节点的最大路径和，进而得到全局最大路径。

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        # write code here

        self.ret = float('-inf')

        def maxGain(node):
            if not node: return 0

            # 如果子路径的 maxGain 为负数，那么对 node 来说 maxGain 就是自己本身；
            max_left = max(0, maxGain(node.left))
            max_right = max(0, maxGain(node.right))
            # 记录“经过”node 节点的最大路径
            self.ret = max(self.ret, node.val + max_left + max_right)
            return node.val + max(max_left, max_right)  # 至少要包含自己本身

        maxGain(root)
        return self.ret
```

</details>

---

### `牛客 0007 买卖股票的最好时机(一) (简单, 2022-01)`

[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["模拟"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0007",
    "标题": "买卖股票的最好时机(一)",
    "公司": ["字节", "腾讯"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定一支股票的价格序列，返回买卖一次的最大值；
```
> [买卖股票的最好时机(一)_牛客题霸_牛客网](https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：动态规划</b></summary>

- 记 `dp[i]` 表示 `prices[:i]` 中的最小值；
- 则 `ret = max(x - dp[i])`；
- 实际可以用一个变量记录当前最小值，节省空间；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param prices int整型一维数组 
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        # write code here
        ret = 0
        min_p = prices[0]
        for x in prices[1:]:
            ret = max(ret, x - min_p)
            min_p = min(x, min_p)
        return ret
```

</details>

---

### `牛客 0008 二叉树中和为某一值的路径(二) (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0008",
    "标题": "二叉树中和为某一值的路径(二)",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和目标值 target，返回所有和为 target 的路径。
规定路径必须从根节点开始到叶子节点。
```
> [二叉树中和为某一值的路径(二)_牛客题霸_牛客网](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param target int整型 
# @return int整型二维数组
#
class Solution:
    def FindPath(self , root: TreeNode, target: int) -> List[List[int]]:
        # write code here
        
        ret = []
        tmp = []
        
        def dfs(node, k):
            if not node: return
            
            tmp.append(node.val)
            k -= node.val
            
            if not node.left and not node.right and k == 0:
                ret.append(tmp[:])
            
            dfs(node.left, k)
            dfs(node.right, k)
            k += node.val
            tmp.pop()
        
        dfs(root, target)
        return ret
```

</details>

---

### `牛客 0009 二叉树中和为某一值的路径(一) (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0009",
    "标题": "二叉树中和为某一值的路径(一)",
    "公司": ["腾讯", "字节", "京东"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和目标值 target，判断是否存在路径和等于 target。
规定路径必须从根节点开始到叶子节点。
```
> [二叉树中和为某一值的路径(一)_牛客题霸_牛客网](https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return bool布尔型
#
class Solution:
    def hasPathSum(self , root: TreeNode, sum: int) -> bool:
        # write code here
        
        def dfs(node, k):
            if not node: return False
            
            if k == node.val and not node.left and not node.right:
                return True
            
            return dfs(node.left, k - node.val) or dfs(node.right, k - node.val)
        
        return dfs(root, sum)
```

</details>

---

### `牛客 0010 大数乘法 (中等, 2022-01)`

[![字符串](https://img.shields.io/badge/字符串-lightgray.svg)](数据结构-字符串.md)
[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["字符串", "模拟"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0010",
    "标题": "大数乘法",
    "公司": ["腾讯", "阿里", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
以字符串的形式读入两个数字，编写一个函数计算它们的乘积，以字符串形式返回。
```
> http://

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：模拟</b></summary>

```
以 54 * 68 为例：

    54
  x 68
  -----

用 tmp 记录每一步的结果

8 * 4 = 32      tmp = [32]
8 * 5 = 40      tmp = [40, 32]
6 * 4 = 24      tmp = [40 + 24, 32]
6 * 5 = 30      tmp = [30, 40 + 24, 32]

得到 tmp 后做循环进位加法即可，详见代码；
```

- 示例中按照手算习惯是从低位开始算起的，实际因为各位之间互相独立，从高位开始也可以，详见代码；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 第一个整数
# @param t string字符串 第二个整数
# @return string字符串
#
class Solution:
    def solve(self , s: str, t: str) -> str:
        from collections import deque
        
        # write code here
        tmp = []
        # 从高位开始算起
        for i, a in enumerate(s):
            for j, b in enumerate(t):
                c = int(a) * int(b)
                if i + j == len(tmp):
                    tmp.append(c)
                else:
                    tmp[i + j] += c
        
        ret = deque()
        add = 0  # 进位
        for x in tmp[::-1]:  # 因为要考虑进位，所以从低位开始算起，即逆序遍历
            x += add
            add = x // 10
            ret.appendleft(str(x % 10))  # 这里也可以直接拼字符串，不过推荐用队列
        
        if add:
            ret.appendleft(str(add))
            
        return ''.join(ret)
```

</details>

---

### `牛客 0011 将升序数组转化为平衡二叉搜索树 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0011",
    "标题": "将升序数组转化为平衡二叉搜索树",
    "公司": ["百度", "映客"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定升序数组，转化为平衡二叉搜索树（BST）
```
> [将升序数组转化为平衡二叉搜索树_牛客题霸_牛客网](https://www.nowcoder.com/practice/7e5b00f94b254da599a9472fe5ab283d)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 每次选择中间节点作为根节点，按先序遍历递归构建 BST；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @return TreeNode类
#
class Solution:
    def sortedArrayToBST(self , num: List[int]) -> TreeNode:
        # write code here
        def dfs(arr):
            if not arr: return None
            
            l, r = 0, len(arr) - 1
            mid = (l + r) // 2
            
            node = TreeNode(arr[mid])
            node.left = dfs(arr[:mid])
            node.right = dfs(arr[mid + 1:])
            
            return node
        
        return dfs(num)
```

</details>

---

### `牛客 0012 重建二叉树 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0012",
    "标题": "重建二叉树",
    "公司": ["小米", "携程", "腾讯", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树的前序和中序遍历结果，重建二叉树；
规定二叉树中各节点的值都不相同；
```
> [重建二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 前序遍历的第一个节点为根节点，在中序遍历中找到根节点的位置，其左边部分为左子树，右边为右子树，然后按前序遍历递归构建整个树；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pre int整型一维数组 
# @param vin int整型一维数组 
# @return TreeNode类
#
class Solution:
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        # write code here
        
        def dfs(p, i):
            if not p or not i: return None
            
            val = p[0]
            idx = i.index(val)
            node = TreeNode(val)
            
            node.left = dfs(p[1:idx + 1], i[:idx])
            node.right = dfs(p[idx + 1:], i[idx + 1:])
            
            return node
        
        return dfs(pre, vin)
```

</details>

---

### `牛客 0013 二叉树的最大深度 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0013",
    "标题": "二叉树的最大深度",
    "公司": ["字节", "小米", "阿里"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定二叉树的最大深度。
```
> http://

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxDepth(self , root: TreeNode) -> int:
        # write code here
        
        def dfs(node):
            if not node: return 0
            
            return 1 + max(dfs(node.left), dfs(node.right))
        
        return dfs(root)
```

</details>

---

### `牛客 0014 按之字形顺序打印二叉树 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![队列](https://img.shields.io/badge/队列-lightgray.svg)](数据结构-栈、队列.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树", "队列"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0014",
    "标题": "按之字形顺序打印二叉树",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
层序遍历二叉树，按之字形打印每层。
```
> [按之字形顺序打印二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 队列 + 奇偶讨论，思路比较简单，因为需要把层分离，所以需要借助的辅助变量比较多，详见代码；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return int整型二维数组
#
class Solution:
    def Print(self , pRoot: TreeNode) -> List[List[int]]:
        # write code here
        if not pRoot: return []
        
        from collections import deque
        
        ret = []
        q = deque()
        q.append(pRoot)
        cnt = 1
        nxt = 0  # 下一层需要遍历的节点数
        lv = 0  # 已经遍历的层数
        tmp = []  # 当前层缓存的节点数
        while cnt:
            cnt -= 1
            node = q.popleft()
            tmp.append(node.val)
            
            if node.left:
                q.append(node.left)
                nxt += 1
            if node.right:
                q.append(node.right)
                nxt += 1
            
            if cnt == 0:
                if lv % 2:
                    ret.append(tmp[::-1])
                else:
                    ret.append(tmp)
                tmp = []
                lv += 1
                cnt = nxt
                nxt = 0
                
        return ret
```

</details>

---

### `牛客 0015 求二叉树的层序遍历 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0015",
    "标题": "求二叉树的层序遍历",
    "公司": ["腾讯", "美团", "小米", "神策数据"]
}-->

<summary><b>问题简述</b></summary>

```txt
层序遍历二叉树，每层的结果单独保存在一个列表中。
```
> [求二叉树的层序遍历_牛客题霸_牛客网](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 辅助队列

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型二维数组
#
class Solution:
    def levelOrder(self , root: TreeNode) -> List[List[int]]:
        # write code here
        if not root: return []
        
        from collections import deque
        
        ret = []
        q = deque()
        q.append(root)
        cnt = 1
        nxt = 0
        tmp = []
        while cnt:
            cnt -= 1
            node = q.popleft()
            tmp.append(node.val)
            
            if node.left:
                q.append(node.left)
                nxt += 1
            if node.right:
                q.append(node.right)
                nxt += 1
                
            if cnt == 0:
                ret.append(tmp)
                tmp = []
                cnt = nxt
                nxt = 0
        
        return ret
```

</details>

---

### `牛客 0016 对称的二叉树 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0016",
    "标题": "对称的二叉树",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
判断给定二叉树是否对称。
```
> [对称的二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 跟一般的二叉树递归略有不同，因为对称的二叉树，其子树并不对称；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    def isSymmetrical(self , pRoot: TreeNode) -> bool:
        # write code here
        if not pRoot: return True
        
        def dfs(l, r):
            if not l and not r: return True  # 同时到达叶节点
            if not l or not r: return False
            
            return l.val == r.val and dfs(l.left, r.right) and dfs(l.right, r.left)
            
        return dfs(pRoot.left, pRoot.right)
```

</details>

---

### `牛客 0017 最长回文子串 (中等, 2022-01)`

[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟.md)
[![DP](https://img.shields.io/badge/DP-lightgray.svg)](算法-动态规划(记忆化搜索)、递推.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["模拟", "DP"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0017",
    "标题": "最长回文子串",
    "公司": ["腾讯", "华为", "美团", "京东"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定字符串中最长回文子串的长度。
```
> [最长回文子串_牛客题霸_牛客网](https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：模拟中心扩散（推荐）</b></summary>

- 中心扩散直观，且不需要额外的空间，比动态规划的方法更好；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param A string字符串 
# @return int整型
#
class Solution:
    def getLongestPalindrome(self , A: str) -> int:
        # write code here
        n = len(A)
        
        def process(l, r):
            tmp = 1  # 使用一个变量保存已知的最大长度
            while l >= 0 and r < n:
                if A[l] != A[r]:
                    break
                tmp = r - l + 1
                l -= 1
                r += 1
            # return r - l + 1  # 直接返回有问题，无法判断最后一次是否匹配上
            return tmp
        
        ret = 1
        for i in range(len(A) - 1):
            # 同时处理 process(i, i), process(i, i + 1) 避免奇偶的讨论
            ret = max(ret, process(i, i), process(i, i + 1))
            
        return ret
```

</details>


<summary><b>思路2：动态规划</b></summary>

- DP 虽然能解，但是不够直观，且初始状态容易写错（相邻两个字符相同的情况）；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param A string字符串 
# @return int整型
#
class Solution:
    def getLongestPalindrome(self , A: str) -> int:
        # write code here
        n = len(A)
        dp = [[0] * n for _ in range(n)]

        for i in range(n):
            dp[i][i] = 1
        
        start = 0
        length = 1
        for j in range(1, n):  # 子串的结束位置
            for i in range(j - 1, -1, -1):  # 子串的开始位置
                if i == j - 1:
                    dp[i][j] = 1 if A[i] == A[j] else 0
                else:
                    dp[i][j] = 1 if dp[i + 1][j - 1] and A[i] == A[j] else 0

                if dp[i][j]:
                    if j - i + 1 > length:
                        length = j - i + 1
                        start = i

        return length
```

</details>

---

### `牛客 0018 顺时针旋转矩阵 (简单, 2022-01)`

[![数组](https://img.shields.io/badge/数组-lightgray.svg)](数据结构-数组、矩阵(二维数组).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["数组"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0018",
    "标题": "顺时针旋转矩阵",
    "公司": ["美团", "虾皮", "快手", "华为"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定 NxN 矩阵，和矩阵的阶数 N，返回顺时针旋转 90 度后的矩阵。
```
> [顺时针旋转矩阵_牛客题霸_牛客网](https://www.nowcoder.com/practice/2e95333fbdd4451395066957e24909cc)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 分两步，先按行逆序，再按列逆序（反过来也可以）；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param mat int整型二维数组 
# @param n int整型 
# @return int整型二维数组
#
class Solution:
    def rotateMatrix(self , mat: List[List[int]], n: int) -> List[List[int]]:
        # write code here

        # 法1）先逆序
        # return list(zip(*mat[::-1]))

        # 法2）后逆序
        return [[row[i] for row in mat][::-1] for i in range(n)]
```

</details>

---

### `牛客 0019 连续子数组的最大和 (简单, 2022-01)`

[![DP](https://img.shields.io/badge/DP-lightgray.svg)](算法-动态规划(记忆化搜索)、递推.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["DP"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0019",
    "标题": "连续子数组的最大和",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给定数组 arr，求其连续子数组的最大和。
```
> [连续子数组的最大和_牛客题霸_牛客网](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：动态规划</b></summary>

- 记 `dp[i]` 表示以 `arr[i]` 结尾的最大和；
- 则 `dp[i] = max(dp[i - 1] + arr[i], arr[i])`；
- 因为 `dp[i]` 只与上一个状态有关，因此可以使用滚动变量优化（详见代码）；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param array int整型一维数组 
# @return int整型
#
class Solution:
    def FindGreatestSumOfSubArray(self , array: List[int]) -> int:
        # write code here
        ret = dp = array[0]
        for x in array[1:]:
            dp = max(x, dp + x)
            ret = max(ret, dp)
        
        return ret
```

</details>

---

### `牛客 0020 数字字符串转化成IP地址 (中等, 2022-01)`

[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0020",
    "标题": "数字字符串转化成IP地址",
    "公司": ["百度", "字节", "快手"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定只包含数字的字符串，将该字符串转化成 IP 地址的形式，返回所有可能的情况。
例如：给出的字符串为"25525522135",
返回：["255.255.22.135", "255.255.221.35"]
```
> [数字字符串转化成IP地址_牛客题霸_牛客网](https://www.nowcoder.com/practice/ce73540d47374dbe85b3125f57727e1e)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS + 回溯</b></summary>

- 相当于构建一颗三叉树；

<div align="center"><img src="../_assets/牛客0020.png" height="300" /></div>

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return string字符串一维数组
#
class Solution:
    def restoreIpAddresses(self , s: str) -> List[str]:
        # write code here
        
        ret = []
        
        def valid(x):
            """验证函数"""
            if not x:  # 非空
                return False
            if x.startswith('0') and len(x) > 1:  # 存在前缀 0
                return False
            return int(x) <= 255
        
        def dfs(k, depth, tmp):
            if depth == 3:  # 到第三层的时候，直接判断所有剩余字符
                if valid(s[k:]):
                    tmp.append(s[k:])
                    ret.append('.'.join(tmp))
                    tmp.pop()  # 这里也要回溯
                return
            
            for i in range(1, 4):
                sub = s[k: k + i]
                if valid(sub):
                    tmp.append(sub)
                    dfs(k + i, depth + 1, tmp)
                    tmp.pop()
        
        dfs(0, 0, [])
        return ret
```

</details>

---

### `牛客 0021 链表内指定区间反转 (中等, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["链表"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0021",
    "标题": "链表内指定区间反转",
    "公司": ["字节", "腾讯", "小米", "快手"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定链表 head，把 m 到 n 区间内的节点反转
```
> [链表内指定区间反转_牛客题霸_牛客网](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：模拟</b></summary>

<details><summary><b>Python</b></summary>

```python
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param m int整型 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def reverseBetween(self , head: ListNode, m: int, n: int) -> ListNode:
        # write code here
        
        # 增加一个伪头结点，主要针对完全反转的情况
        dummy = ListNode(0)
        dummy.next = head
        
        cnt = n - m
        pre, cur = dummy, head
        while m - 1:  # 因为要保存开始反转之前的一个节点，所以少移动一次
            m -= 1
            pre = cur
            cur = cur.next
        
        beg, end = pre, cur
        pre, cur = cur, cur.next  # 把少移动的一次补回来
        
        # 开始反转，反转 cnt 次
        while cnt:
            cnt -= 1
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        
        # 重新拼接（可以画图理解为什么是这两个位置拼接）
        beg.next = pre
        end.next = cur
        
        return dummy.next
```

</details>

---

### `牛客 0022 合并两个有序的数组 (中等, 2022-01)`

[![双指针](https://img.shields.io/badge/双指针-lightgray.svg)](技巧-双指针.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["双指针"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0022",
    "标题": "合并两个有序的数组",
    "公司": ["百度", "贝壳", "美团", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定两个有序数组 A 和 B，请将数组 B 合并到数组 A 中；
A 和 B 中初始的元素数目分别为 m 和 n，A 的数组空间大小为 m + n；
要求不使用额外空间。
```
> [合并两个有序的数组_牛客题霸_牛客网](https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 双指针 + 逆序填空；

<details><summary><b>Python</b></summary>

```python
#
# 
# @param A int整型一维数组 
# @param B int整型一维数组 
# @return void
#
class Solution:
    def merge(self , A, m, B, n):
        # write code here
        i, j = m - 1, n - 1
        p = m + n - 1
        
        while i >= 0 and j >= 0:
            if A[i] > B[j]:
                A[p] = A[i]
                i -= 1
            else:
                A[p] = B[j]
                j -= 1
            p -= 1
        
        while j >= 0:
            A[p] = B[j]
            j -= 1
            p -= 1
```

</details>

---

### `牛客 0023 划分链表 (中等, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["链表"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0023",
    "标题": "划分链表",
    "公司": ["百度", "小米"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定链表和一个值 x，将所有小于 x 的值移动到左侧，保持相对顺序；
```
> [划分链表_牛客题霸_牛客网](https://www.nowcoder.com/practice/1dc1036be38f45f19000e48abe00b12f)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 快排中的 partition 操作；
- 因为链表的特殊性，扩展链表并不会带来额外的消耗；
- 考虑维护两个链表，分别保存小于 x 的节点和其他节点；最后将两个链表拼接即可；
- 此外还有一种基于**双指针**的思路：
    - 考虑左指针有右指针，开始时，直接将右指针移动到末尾，然后遍历左指针，遇到大于等于 x 的节点就移动到右指针的位置；

<details><summary><b>Python</b></summary>

```python
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param x int整型 
# @return ListNode类
#
class Solution:
    def partition(self , head: ListNode, x: int) -> ListNode:
        # write code here
        
        small = l = ListNode(0)
        large = r = ListNode(0)
        
        cur = head
        while cur:
            if cur.val < x:
                l.next = cur
                l = l.next
            else:
                r.next = cur
                r = r.next
            cur = cur.next
        
        l.next = large.next
        r.next = None
        return small.next
```

</details>

---

### `牛客 0091 最长上升子序列(三) (困难, 2022-02)`

[![DP](https://img.shields.io/badge/DP-lightgray.svg)](算法-动态规划(记忆化搜索)、递推.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["DP"],
    "来源": "牛客",
    "难度": "困难",
    "编号": "0091",
    "标题": "最长上升子序列(三)",
    "公司": ["字节", "百度"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定数组，返回字典序最小的最长上升子序列；
```
> [最长上升子序列(三)_牛客题霸_牛客网](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：动态规划</b></summary>

- 为了返回字典序最小的 LIS，本题需要结合两种 DP 状态；
    - 记 `dp_end[i]` 表示长度为 `(i+1)` 的 LIS 结尾的最小值；
    - 记 `dp_len[i]` 表示以 `arr[i]` 结尾的 LIS 的长度；
    > 这两种状态都可以用来求 LIS 的长度，前者的时间复杂度为 $O(n\log n)$，后者为 $O(n^2)$
- 得到这两个状态序列后就可以来计算具体的 LIS 了；下面举例说明如何使用这两个状态来还原 LIS；
    ```
    arr:    [1,2,8,6,4]
    dp_len: [1,2,3,3,3]
    dp_end: [1,2,4]
    # 这里省略了这两个状态序列的生成过程，
    # 因为 dp_len 可以在计算 dp_end 的过程中一起获得，因此时间复杂度依然是 `O(NlogN)`

    初始化：
        ret = [0] * len(dp_end)  # 保存 LIS
        cnt = len(dp_end) # LIS 的长度

    然后逆序遍历 dp_len
    当 dp_len[i] == cnt 时，将 ret[cnt - 1] 赋值为 arr[i]，同时 cnt -= 1

    为什么要逆序遍历？
        举个例子，arr 结尾的三个数，其最大的 LIS 长度都是 3，但其中 4 是最小的，
        因为如果它不是最小的，意味着它对应的 LIS 长度就应该大于 3 了
    ```

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# retrun the longest increasing subsequence
# @param arr int整型一维数组 the array
# @return int整型一维数组
#
class Solution:
    def LIS(self, arr: List[int]) -> List[int]:
        # write code here
        if not arr: return []

        from bisect import bisect_left

        dp_end = [arr[0]]  # dp_end[i] 表示长度为 (i+1) 的 LIS 结尾的最小值
        dp_len = [1]  # dp_len[i] 表示以 arr[i] 结尾的 LIS 的长度
        for x in arr[1:]:
            if x > dp_end[-1]:
                dp_end.append(x)
                dp_len.append(len(dp_end))
            else:
                idx = bisect_left(dp_end, x)
                dp_end[idx] = x
                dp_len.append(idx + 1)

        cnt = len(dp_end)
        ret = [0] * len(dp_end)
        for i in range(len(arr) - 1, -1, -1):
            if dp_len[i] == cnt:
                cnt -= 1
                ret[cnt] = arr[i]
        
        return ret
```

</details>

---

### `牛客 0145 01背包 (中等, 2022-02)`

[![DP](https://img.shields.io/badge/DP-lightgray.svg)](算法-动态规划(记忆化搜索)、递推.md)
[![DFS2DP](https://img.shields.io/badge/DFS2DP-lightgray.svg)](技巧-从暴力递归到动态规划.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["DP", "DFS2DP"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0145",
    "标题": "01背包",
    "公司": ["阿里"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定最多能容纳 V 体积的背包，和 n 个物品，每个物品有重量(w)和体积(v)两个属性；
求背包能放的最大重量；
每个物品的重量(w)和体积(v)保存在数组 vw 中；

示例1：
    输入：10,2,[[1,3],[10,4]]
    返回：4
示例2：
    输入：10,2,[[1,3],[9,8]]
    返回：11
```
> [01背包_牛客题霸_牛客网](https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：单向暴力递归</b></summary>

- 本题“从左往右”和“从右往左”没有区别，因为不存在依赖关系——你从左边开始取物品和从右边开始没有区别；

<details><summary><b>Python：写法1）从左往右</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self , V: int, n: int, vw: List[List[int]]) -> int:
        # write code here
        
        # 函数定义：从第 i 个物品开始取，剩余容量为 rest 的情况下，能得到的最大重量
        def recur(i, rest):
            if i == n:  # 因为下标从 0 开始，所以 i == n 表示当期已经没有物品可以取，因此最大重量为 0
                ret = 0
            elif rest < vw[i][0]:  # 如果剩余容量不足以放下当期物品，只能跳过在从下一个物品开始
                ret = recur(i + 1, rest)
            else:  # 如果能取当前物品，根据取与不取当前物品，返回其中的最大值
                ret = max(recur(i + 1, rest), recur(i + 1, rest - vw[i][0]) + vw[i][1])
            return ret

        return recur(0, V)
```

</details>

<details><summary><b>Python：写法2）从右往左（本题没有区别，均可）</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self , V: int, n: int, vw: List[List[int]]) -> int:
        # write code here
        
        # 函数定义：从第 i 个物品开始取，剩余容量为 rest 的情况下，能得到的最大重量
        def recur(i, rest):
            if i == 0:  # 因为下标从 n-1 开始，所以 i == 0 表示当期已经没有物品可以取，因此最大重量为 0
                ret = 0
            elif rest < vw[i][0]:  # 如果剩余容量不足以放下当期物品，只能跳过在从下一个物品开始
                ret = recur(i - 1, rest)
            else:  # 如果能取当前物品，根据取与不取当前物品，返回其中的最大值
                ret = max(recur(i - 1, rest), recur(i - 1, rest - vw[i][0]) + vw[i][1])
            return ret

        return recur(n - 1, V)
```

</details>


<summary><b>思路2：在递归过程中加入记忆化搜索</b></summary>

<details><summary><b>Python：从左往右</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self , V: int, n: int, vw: List[List[int]]) -> int:
        # write code here
        import sys
        sys.setrecursionlimit(1010)  # 解除递归深度限制
        
        dp = dict()
        
        def recur(i, rest):
            if (i, rest) in dp:
                return dp[(i, rest)]
            
            if i == n:
                ret = 0
            elif rest < vw[i][0]:
                ret = recur(i + 1, rest)
            else:
                ret = max(recur(i + 1, rest), recur(i + 1, rest - vw[i][0]) + vw[i][1])
            dp[(i, rest)] = ret
            return ret

        return recur(0, V)
```

</details>


<details><summary><b>Python：使用标准库提供的缓存方法</b></summary>

- 不知道什么原因无法通过全部用例，好像 `lru_cache` 和 `setrecursionlimit` 不能同时生效；

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self , V: int, n: int, vw: List[List[int]]) -> int:
        # write code here
        import sys
        sys.setrecursionlimit(1010)  # 解除递归深度限制

        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def recur(i, rest):
            if i == n:
                ret = 0
            elif rest < vw[i][0]:
                ret = recur(i + 1, rest)
            else:
                ret = max(recur(i + 1, rest), recur(i + 1, rest - vw[i][0]) + vw[i][1])
            return ret

        return recur(0, V)
```

</details>


<summary><b>思路3：将暴力递归转化为动态规划</b></summary>

<details><summary><b>Python：从左往右</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算01背包问题的结果
# @param V int整型 背包的体积
# @param n int整型 物品的个数
# @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
# @return int整型
#
class Solution:
    def knapsack(self, V: int, n: int, vw: List[List[int]]) -> int:
        # write code here

        # dp = dict()
        dp = [[0] * (V + 1) for _ in range(n + 1)]

        # 第 0 步，从递归的返回看 dp 的返回
        #   从左往右中，返回的是 recue(0, V)，对应就是 dp[0][V]
        #   从右往左中，返回的是 recue(n - 1, V)，对应就是 dp[n - 1][V]
        # 通过这一步提前判断遍历方向

        # 第 1 步：dp初始化，对应递归中的 base case
        #   因为申请 dp 的时候已经初始化为 0 了，所以这里可以省略
        # for j in range(V + 1):
        #     dp[n][j] = 0

        # 第 2 步，把递归过程一一对应到 dp 位置即可
        #   因为初始化把 i == n 的情况都填完了，所以 i 从 n-1 开始
        for i in range(n - 1, -1, -1):
            # 因为本题只有行依赖，没有列依赖，所以对 V 的遍历顺序没有要求
            #   什么意思呢？就是你在递归的时候走 rest < vw[i][0] 分支和 rest >= vw[i][0] 分支的时候没有顺序要求，先判断哪个都可以
            #   应用到这里就是以下两种遍历方向都可以
            # for rest in range(V, -1, -1):  # 相当于先判断 rest >= vw[i][0]
            for rest in range(1, V + 1):  # 相当于先判断 rest < vw[i][0]
                if rest < vw[i][0]:
                    # ret = recur(i + 1, rest)
                    dp[i][rest] = dp[i + 1][rest]
                else:
                    # ret = max(recur(i + 1, rest), vw[i][1] + recur(i + 1, rest - vw[i][0]))
                    dp[i][rest] = max(dp[i + 1][rest], dp[i + 1][rest - vw[i][0]] + vw[i][1])

        # return recur(0, V)
        return dp[0][V]
```

</details>

---
