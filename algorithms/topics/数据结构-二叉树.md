# 二叉树

<!-- Tag: 树、二叉树、二叉搜索树 -->

- [二叉树的遍历](#二叉树的遍历)
    - [先序/中序/后序遍历](#先序中序后序遍历)
    - [层序遍历](#层序遍历)
- [二叉树的重建](#二叉树的重建)
    - [利用中序+前序/后序的遍历结果重建](#利用中序前序后序的遍历结果重建)
    - [利用层序遍历结果重建二叉树](#利用层序遍历结果重建二叉树)
- [二叉搜索树（BST）](#二叉搜索树bst)
    - [基本性质](#基本性质)

## 二叉树的遍历

```txt
// 输入：[1,2,3,4,5,6,7]

//      1
//    /   \
//   2     3
//  / \   / \
// 4   5 6   7

// 先序：[1,2,4,5,3,6,7]
// 中序：[4,2,5,1,6,3,7]
// 后序：[4,5,2,6,7,3,1]
// 层序：[1,2,4,5,3,6,7]
```

### 先序/中序/后序遍历
- 先序/中序/后序的区别（详见代码）：
    - 首先访问根节点就是**先序**；
    - 中间访问根节点就是**中序**；
    - 最后访问根节点就是**后序**；

<details><summary><b>代码（C++）</b></summary>

```cpp

/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/
class Solution {

public:
    vector<int> tmp(TreeNode* root) {
        vector<int> ret;
        preOrder(root, ret);
        return ret;
    }

    // 前序遍历
    void preOrder(TreeNode* root, vector<int> &arr) {
        if (root == nullptr) return;

        arr.push_back(root->val);  // 先序
        preOrder(root->left, arr);
        preOrder(root->right, arr);
    }

    // 中序遍历
    void inOrder(TreeNode* root, vector<int> &arr) {
        if (root == nullptr) return;

        inOrder(root->left, arr);
        arr.push_back(root->val);  // 中序
        inOrder(root->right, arr);
    }

    // 后序遍历
    void postOrder(TreeNode* root, vector<int> &arr) {
        if (root == nullptr) return;

        postOrder(root->left, arr);
        postOrder(root->right, arr);
        arr.push_back(root->val);  // 后序
    }
};
```

</details>


### 层序遍历
1. 申请辅助队列 q；
2. 将树的根结点入队；
3. 如果 q 不为空，则将头结点出队记为 node；如果 node 的左节点不为空，则将左节点入队；如果 node 的右节点不为空，则将右节点入队；
4. 重复 2、3，直到 q 为空

<details><summary><b>代码（C++）</b></summary>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {

public:
    vector<int> levelOrder(TreeNode* root) {
        
        vector<int> ret;
        queue<TreeNode*> q;  // 辅助队列
        
        if (root) {
            q.push(root);
        }

        while (!q.empty()) {
            TreeNode* node = q.front();  // 取出并弹出队首
            q.pop();

            ret.push_back(node->val);
            if (node->left) {
                q.push(node->left);
            }
            if (node->right) {
                q.push(node->right);
            }
        }

        return ret;
    }
};
```

</details>


## 二叉树的重建

### 利用中序+前序/后序的遍历结果重建

- 单独的中序/前序/后序遍历结果都无法重建二叉树；
- 必须要**中序 + 前序/后序**才能重建，且**树中节点的值要互不相同**；

<details><summary><b>Python</b></summary>

```python
def build_dfs(p, i):  # 输入前序遍历和中序遍历
    if len(p) < 1 or len(i) < 1:
        return None

    # 建立根节点
    root_val = p[0]
    root = TreeNode(root_val)
    root_idx = i.index(root_val)  # 找到根节点在中序遍历的位置

    # 截取左子树的 preorder 和 inorder，递归建立左子树
    i_left = i[:root_idx]
    p_left = p[1: len(i_left) + 1]
    root.left = dfs(p_left, i_left)
    # 截取右子树的 preorder 和 inorder，递归建立右子树
    i_right = i[root_idx + 1:]
    p_right = p[-len(i_right):]
    root.right = dfs(p_right, i_right)

    return root
```

</details>

### 利用层序遍历结果重建二叉树

- 因为层序遍历的结果中可以保留空节点，因此即使树中存在相同节点，也可以还原；
- 还原过程与层序遍历过程相似，同样要借助辅助队列；


<details><summary><b>Python</b></summary>

```python
def build(nodes):
    """nodes 形如 [1,2,3,None,None,4,5]"""
    if not nodes: return None  # 空

    from collections import deque  # 双端队列

    i = 0  # 记录当前节点在 data 中的位置
    root = Node(nodes[i])
    i += 1
    buf = deque([root])
    while buf:
        p = buf.popleft()
        if nodes[i] is not None:  # 因为在 if 中 0 也是 False，所以保险起见用 is not None 来判断
            p.left = Node(nodes[i])
            buf.append(p.left)
        i += 1
        if nodes[i] is not None:
            p.right = Node(nodes[i])
            buf.append(p.right)
        i += 1

    return root
```

</details>


## 二叉搜索树（BST）
> 又称“二叉排序树”、“二叉查找树”等；

### 基本性质

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 其左、右子树也分别为二叉排序树。
- 其**先序/后序遍历**的结果是一个有序数组；

Problems
---
- [`LeetCode 0104 二叉树的最大深度 (简单, 2021-10)`](#leetcode-0104-二叉树的最大深度-简单-2021-10)
- [`LeetCode 0111 二叉树的最小深度 (简单, 2021-10)`](#leetcode-0111-二叉树的最小深度-简单-2021-10)
- [`LeetCode 0112 路径总和 (简单, 2022-02)`](#leetcode-0112-路径总和-简单-2022-02)
- [`LeetCode 0113 路径总和II (中等, 2022-02)`](#leetcode-0113-路径总和ii-中等-2022-02)
- [`LeetCode 0129 求根节点到叶节点数字之和 (中等, 2022-02)`](#leetcode-0129-求根节点到叶节点数字之和-中等-2022-02)
- [`LeetCode 0257 二叉树的所有路径 (简单, 2022-02)`](#leetcode-0257-二叉树的所有路径-简单-2022-02)
- [`LeetCode 0437 路径总和III (中等, 2022-02)`](#leetcode-0437-路径总和iii-中等-2022-02)
- [`LeetCode 0988 从叶结点开始的最小字符串 (中等, 2022-02)`](#leetcode-0988-从叶结点开始的最小字符串-中等-2022-02)
- [`剑指Offer 0700 重建二叉树 (中等, 2021-11)`](#剑指offer-0700-重建二叉树-中等-2021-11)
- [`剑指Offer 2600 树的子结构 (中等, 2021-11)`](#剑指offer-2600-树的子结构-中等-2021-11)
- [`剑指Offer 2700 二叉树的镜像 (简单, 2021-11)`](#剑指offer-2700-二叉树的镜像-简单-2021-11)
- [`剑指Offer 2800 对称的二叉树 (简单, 2021-11)`](#剑指offer-2800-对称的二叉树-简单-2021-11)
- [`剑指Offer 3201 层序遍历二叉树 (简单, 2021-11)`](#剑指offer-3201-层序遍历二叉树-简单-2021-11)
- [`剑指Offer 3202 层序遍历二叉树 (简单, 2021-11)`](#剑指offer-3202-层序遍历二叉树-简单-2021-11)
- [`剑指Offer 3203 层序遍历二叉树（之字形遍历） (简单, 2021-11)`](#剑指offer-3203-层序遍历二叉树之字形遍历-简单-2021-11)
- [`剑指Offer 3300 二叉搜索树的后序遍历序列 (中等, 2021-12)`](#剑指offer-3300-二叉搜索树的后序遍历序列-中等-2021-12)
- [`剑指Offer 3400 二叉树中和为某一值的路径 (中等, 2021-12)`](#剑指offer-3400-二叉树中和为某一值的路径-中等-2021-12)
- [`剑指Offer 3600 二叉搜索树与双向链表 (中等, 2021-12)`](#剑指offer-3600-二叉搜索树与双向链表-中等-2021-12)
- [`剑指Offer 3700 序列化二叉树 (困难, 2021-12)`](#剑指offer-3700-序列化二叉树-困难-2021-12)
- [`剑指Offer 5400 二叉搜索树的第k大节点 (简单, 2022-01)`](#剑指offer-5400-二叉搜索树的第k大节点-简单-2022-01)
- [`剑指Offer 5501 求二叉树的深度 (简单, 2022-01)`](#剑指offer-5501-求二叉树的深度-简单-2022-01)
- [`剑指Offer 5502 判断是否为平衡二叉树 (简单, 2022-01)`](#剑指offer-5502-判断是否为平衡二叉树-简单-2022-01)
- [`剑指Offer 6802 二叉树的最近公共祖先 (简单, 2022-01)`](#剑指offer-6802-二叉树的最近公共祖先-简单-2022-01)
- [`牛客 0005 二叉树根节点到叶子节点的所有路径和 (中等, 2022-01)`](#牛客-0005-二叉树根节点到叶子节点的所有路径和-中等-2022-01)
- [`牛客 0006 二叉树中的最大路径和 (较难, 2022-01)`](#牛客-0006-二叉树中的最大路径和-较难-2022-01)
- [`牛客 0008 二叉树中和为某一值的路径(二) (中等, 2022-01)`](#牛客-0008-二叉树中和为某一值的路径二-中等-2022-01)
- [`牛客 0009 二叉树中和为某一值的路径(一) (简单, 2022-01)`](#牛客-0009-二叉树中和为某一值的路径一-简单-2022-01)
- [`牛客 0011 将升序数组转化为平衡二叉搜索树 (简单, 2022-01)`](#牛客-0011-将升序数组转化为平衡二叉搜索树-简单-2022-01)
- [`牛客 0012 重建二叉树 (中等, 2022-01)`](#牛客-0012-重建二叉树-中等-2022-01)
- [`牛客 0013 二叉树的最大深度 (简单, 2022-01)`](#牛客-0013-二叉树的最大深度-简单-2022-01)
- [`牛客 0014 按之字形顺序打印二叉树 (中等, 2022-01)`](#牛客-0014-按之字形顺序打印二叉树-中等-2022-01)
- [`牛客 0015 求二叉树的层序遍历 (中等, 2022-01)`](#牛客-0015-求二叉树的层序遍历-中等-2022-01)
- [`牛客 0016 对称的二叉树 (简单, 2022-01)`](#牛客-0016-对称的二叉树-简单-2022-01)

---

### `LeetCode 0104 二叉树的最大深度 (简单, 2021-10)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![递归](https://img.shields.io/badge/递归-lightgray.svg)](算法-递归、迭代.md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["二叉树", "递归"],
    "来源": "LeetCode",
    "编号": "0104",
    "难度": "简单",
    "标题": "二叉树的最大深度"
}-->

<summary><b>问题描述</b></summary>

```txt
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

示例：
    给定二叉树 [3,9,20,null,null,15,7]，
        3
       / \
      9  20
        /  \
       15   7
    返回它的最大深度 3 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<summary><b>思路</b></summary>

- 递归：当前二叉树的最大深度等于**左右子树的最大深度** `+ 1`

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:  # 尾递归
            return 0
        
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

</details>

---

### `LeetCode 0111 二叉树的最小深度 (简单, 2021-10)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "LeetCode",
    "编号": "0111",
    "难度": "简单",
    "标题": "二叉树的最小深度"
}-->

<summary><b>问题描述</b></summary>

```txt
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

示例：
    给定二叉树 [3,9,20,null,null,15,7]，
        3
       / \
      9  20
        /  \
       15   7
    返回它的最小深度 2 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<summary><b>思路</b></summary>

- 深度优先搜索，记录过程中的最小深度；

<details><summary><b>Python：深度优先搜索</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        """"""
        if not root:  # 尾递归1
            return 0

        if not root.left and not root.right:  # 尾递归 2 *
            return 1
        
        min_depth = 10**5 + 10
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth)
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth)
        
        return min_depth + 1
```

</details>

---

### `LeetCode 0112 路径总和 (简单, 2022-02)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["二叉树"],
    "来源": "LeetCode",
    "难度": "简单",
    "编号": "0112",
    "标题": "路径总和",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。
```
> [112. 路径总和 - 力扣（LeetCode）](https://leetcode-cn.com/problems/path-sum/)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 先序遍历，达到叶子节点是进行判断；
- 注意空节点的判断；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:

        def dfs(x, rest):
            if not x:
                return False
            
            rest -= x.val
            if not x.left and not x.right:
                return rest == 0
            l, r = dfs(x.left, rest), dfs(x.right, rest)
            rest += x.val
            return l or r
        
        ret = dfs(root, targetSum)
        return ret
```

</details>

---

### `LeetCode 0113 路径总和II (中等, 2022-02)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["二叉树"],
    "来源": "LeetCode",
    "难度": "中等",
    "编号": "0113",
    "标题": "路径总和II",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。
```
> [113. 路径总和 II - 力扣（LeetCode）](https://leetcode-cn.com/problems/path-sum-ii/)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 先序遍历+回溯；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        
        ret = []
        tmp = []

        def dfs(x, rest):
            if not x:
                return 
            
            rest -= x.val
            tmp.append(x.val)
            if not x.left and not x.right:
                if rest == 0:
                    ret.append(tmp[:])
                
            dfs(x.left, rest)
            dfs(x.right, rest)
            rest += x.val
            tmp.pop()
        
        dfs(root, targetSum)
        return ret
```

</details>

---

### `LeetCode 0129 求根节点到叶节点数字之和 (中等, 2022-02)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["二叉树"],
    "来源": "LeetCode",
    "难度": "中等",
    "编号": "0129",
    "标题": "求根节点到叶节点数字之和",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。
```
> [129. 求根节点到叶节点数字之和 - 力扣（LeetCode）](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：先序遍历</b></summary>

- 先序遍历，每到一个叶节点，add 一次；
- 注意空节点的处理；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:

        self.ret = 0

        def dfs(x, tmp):
            if not x:
                return

            tmp = tmp * 10 + x.val
            if not x.left and not x.right:
                self.ret += tmp
                return
            
            dfs(x.left, tmp)
            dfs(x.right, tmp)
        
        dfs(root, 0)
        return self.ret
```

</details>

---

### `LeetCode 0257 二叉树的所有路径 (简单, 2022-02)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["二叉树"],
    "来源": "LeetCode",
    "难度": "简单",
    "编号": "0257",
    "标题": "二叉树的所有路径",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。
```
> [257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode-cn.com/problems/binary-tree-paths/)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 先序遍历，特殊处理叶子节点；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        
        ret = []
        tmp = []

        def dfs(x):
            if not x: return 
            
            tmp.append(str(x.val))
            if not x.left and not x.right:
                ret.append('->'.join(tmp))
            
            dfs(x.left)
            dfs(x.right)
            tmp.pop()
        
        dfs(root)
        return ret
```

</details>

---

### `LeetCode 0437 路径总和III (中等, 2022-02)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![深度优先搜索](https://img.shields.io/badge/深度优先搜索-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![前缀和](https://img.shields.io/badge/前缀和-lightgray.svg)](技巧-前缀和.md)
[![TreeDP](https://img.shields.io/badge/TreeDP-lightgray.svg)](技巧-自底向上的递归技巧.md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["二叉树", "深度优先搜索", "前缀和", "TreeDP"],
    "来源": "LeetCode",
    "编号": "0437",
    "难度": "中等",
    "标题": "路径总和III",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
```
> [437. 路径总和 III - 力扣（LeetCode）](https://leetcode-cn.com/problems/path-sum-iii/)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：先序遍历</b></summary>

- 先序遍历每个节点，每个节点再先序遍历找目标值；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:  # noqa
        """"""
        if root is None:
            return 0

        def dfs(x, rest):
            if not x:
                return 0

            ans = 0 if x.val != rest else 1  # 如果相等说明，从头结点开始到该节点可以形成一条路径

            # 继续遍历左右子树
            rest -= x.val
            ans += dfs(x.left, rest)
            ans += dfs(x.right, rest)
            rest += x.val  # 回溯
            return ans

        # dfs 是一个先序遍历
        ret = dfs(root, targetSum)
        # pathSum 本身也是一个先序遍历，相当于对每个点都做一次 dfs
        ret += self.pathSum(root.left, targetSum)
        ret += self.pathSum(root.right, targetSum)

        return ret
```

</details>


<summary><b>思路2：先序遍历+前缀和（最优）</b></summary>

> [【宫水三叶】一题双解 :「DFS」&「前缀和」 - 路径总和 III - 力扣（LeetCode）](https://leetcode-cn.com/problems/path-sum-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/)

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        from collections import defaultdict
        self.prefix = defaultdict(int)  # 保存前缀和
        self.prefix[0] = 1
        self.targetSum = targetSum

        def dfs(x, preSum):
            if not x: return 0

            ret = 0
            preSum += x.val
            ret += self.prefix[preSum - targetSum]

            self.prefix[preSum] += 1
            ret += dfs(x.left, preSum)
            ret += dfs(x.right, preSum)
            self.prefix[preSum] -= 1

            return ret

        return dfs(root, 0)
```

</details>


<summary><b>思路3：后序遍历（树形DP）（推荐）</b></summary>

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        from collections import defaultdict
        self.prefix = defaultdict(int)  # 保存前缀和
        self.prefix[0] = 1
        self.targetSum = targetSum

        def dfs(x, preSum):
            if not x: return 0

            ret = 0
            preSum += x.val
            ret += self.prefix[preSum - targetSum]

            self.prefix[preSum] += 1
            ret += dfs(x.left, preSum)
            ret += dfs(x.right, preSum)
            self.prefix[preSum] -= 1

            return ret

        return dfs(root, 0)
```

</details>

---

### `LeetCode 0988 从叶结点开始的最小字符串 (中等, 2022-02)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![LeetCode](https://img.shields.io/badge/LeetCode-lightgray.svg)](合集-LeetCode.md)

<!--{
    "tags": ["二叉树"],
    "来源": "LeetCode",
    "难度": "中等",
    "编号": "0988",
    "标题": "从叶结点开始的最小字符串",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给定一颗根结点为 root 的二叉树，树中的每一个结点都有一个从 0 到 25 的值，分别代表字母 'a' 到 'z'：值 0 代表 'a'，值 1 代表 'b'，依此类推。

找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。
```
> [988. 从叶结点开始的最小字符串 - 力扣（LeetCode）](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：先序遍历</b></summary>

- 自顶向下先序遍历即可，使用一个全局变量记录最小值；
- 踩坑：第一眼想到的是后序遍历，即贪心的查找每个节点的最小值，但在这里局部最优不能推出全局最优；
    > 用例1：`[4,0,1,1]` 错误: `"be"` 预期: `"bae"`  
    > 用例2：`[25,1,null,0,0,1,null,null,null,0]` 错误: `"abz"` 预期: `"ababz"`


<details><summary><b>Python：写法1）回溯（推荐）</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:

        from collections import deque
        
        self.ret = '~'  # '~' > 'z'

        def get_c(v):  # 数字转字母
            return chr(97 + v)

        def dfs(x, buf):  # 先序遍历
            if not x: return

            buf.appendleft(get_c(x.val))
            if not x.left and not x.right:  # 当达到叶子节点时比较
                self.ret = min(self.ret, ''.join(buf))

            dfs(x.left, buf)
            dfs(x.right, buf)
            buf.popleft()  # 记得回溯
        
        dfs(root, deque())
        return self.ret
```

</details>


<details><summary><b>Python：写法2）不回溯，直接修改实参</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:

        self.ret = '~'  # '~' > 'z'

        def get_c(v):  # 数字转字母
            return chr(97 + v)

        def dfs(x, buf):  # 先序遍历
            if not x: return

            if not x.left and not x.right:  # 当达到叶子节点时比较
                self.ret = min(self.ret, get_c(x.val) + buf)

            # 不回溯，直接修改实参
            dfs(x.left, get_c(x.val) + buf)
            dfs(x.right, get_c(x.val) + buf)
        
        dfs(root, '')
        return self.ret
```

</details>

---

### `剑指Offer 0700 重建二叉树 (中等, 2021-11)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![分治](https://img.shields.io/badge/分治-lightgray.svg)](算法-分治.md)
[![经典](https://img.shields.io/badge/经典-lightgray.svg)](基础-经典问题&代码.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树", "分治", "经典"],
    "来源": "剑指Offer",
    "编号": "0700",
    "难度": "中等",
    "标题": "重建二叉树"
}-->

<summary><b>问题简述</b></summary>

```txt
给出二叉树前序遍历和中序遍历的结果，重建该二叉树并返回其根节点。
```

<details><summary><b>详细描述</b></summary>

```txt
输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

示例 1:
    Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
    Output: [3,9,20,null,null,15,7]
示例 2:
    Input: preorder = [-1], inorder = [-1]
    Output: [-1]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

</details>


<summary><b>思路</b></summary>

- 前序遍历，节点按照 `[ 根节点 | 左子树 | 右子树 ]` 的顺序输出。
- 中序遍历，节点按照 `[ 左子树 | 根节点 | 右子树 ]` 的顺序输出。
- 可知：
    - 前序遍历的首元素为根节点 node 的值。
    - 在中序遍历的结果中搜索根节点的索引 ，可将**中序遍历**划分为 `[ 左子树 | 根节点 | 右子树 ]` 。
    - 根据中序遍历中的左（右）子树的节点数量，可将**前序遍历**划分为 `[ 根节点 | 左子树 | 右子树 ]` 。

<div align="center"><img src="../_assets/剑指Offer_0007_中等_重建二叉树.png" height="300" /></div>


<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if len(preorder) < 1 or len(inorder) < 1:  # 两个都判断一下
            return None

        # 建立根节点
        root_val = preorder[0]
        root = TreeNode(root_val)
        root_idx = inorder.index(root_val)  # 找到根节点在中序遍历的位置

        # 截取左子树的 preorder 和 inorder，递归建立左子树
        inorder_left = inorder[:root_idx]
        preorder_left = preorder[1: len(inorder_left) + 1]
        root.left = self.buildTree(preorder_left, inorder_left)
        # 截取右子树的 preorder 和 inorder，递归建立右子树
        inorder_right = inorder[root_idx + 1:]
        preorder_right = preorder[-len(inorder_right):]
        root.right = self.buildTree(preorder_right, inorder_right)
        return root
```

- 更常见的写法会使用一个字典来保存每个节点在中序遍历中的位置，取代`root_idx = inorder.index(root_val)` 这一步，
- 但是这样做就必须每次从最初的 preorder 和 inorder 中截取左右子树的片段，代码会变得比较复杂，传递的参数比较多，故没有采用这种写法；

</details>

---

### `剑指Offer 2600 树的子结构 (中等, 2021-11)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![递归](https://img.shields.io/badge/递归-lightgray.svg)](算法-递归、迭代.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树", "递归"],
    "来源": "剑指Offer",
    "编号": "2600",
    "难度": "中等",
    "标题": "树的子结构"
}-->

<summary><b>问题简述</b></summary>

```txt
输入两棵二叉树A和B，判断B是不是A的子结构(约定空树不是任意一个树的子结构)
```

<details><summary><b>详细描述</b></summary>

```txt
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
    给定的树 A:
         3
        / \
       4   5
      / \
     1   2
    
    给定的树 B：
       4 
      /
     1
    返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：
    输入：A = [1,2,3], B = [3,1]
    输出：false
示例 2：
    输入：A = [3,4,5,1,2], B = [4,1]
    输出：true

限制：
    0 <= 节点个数 <= 10000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<!-- <div align="center"><img src="./_assets/xxx.png" height="300" /></div> -->

</details>


<summary><b>思路：递归遍历</b></summary>

> [树的子结构（先序遍历 + 包含判断，清晰图解）](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/)


1. 确定 b 是 a（以 a 为根节点） 的子结构：
    - 如果 b 与 a 是否相等；
    - 递归判断 b 和 a 的**左、右子节点是否分别相等**；
    - 如果 b 比 a 先达到空节点，则 b 是 a 的子结构；
2. 遍历 A 中的每个节点 a（以任意顺序遍历均可），然后确定 B 是否为 a 的子结构；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        # 题目设定如果原始输入的 B 是空树，则不是 A 的子树
        # 显然当 A 是空树是，B 也不是 A 的子树
        if not B or not A: return False

        def dfs(a, b):
            """同时从 a 和 b 的根节点开始，判断 b 是不是 a 的子树"""
            # 递归中止条件：
            #   如果 b 先于 a 达到空节点，则 b 是 a 的子树；反之不是；所以需要先判断 b
            if not b: return True
            if not a: return False

            if a.val == b.val:  # 如果当前节点值相同，分别递归判断 a 和 b 的左右子树（这里不要求顺序）
                return dfs(a.left, b.left) and dfs(a.right, b.right)
            else:
                return False
        
        # 遍历 A 中的每个节点，判断以其作为根节点，是否包含 B
        #   这里任意遍历顺序都可以，只要能达到 A 中每个节点
        
        # 先序
        # return dfs(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B)
        
        # 中序
        # return self.isSubStructure(A.left, B) or dfs(A, B) or self.isSubStructure(A.right, B)
        
        # 后序
        return self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B) or dfs(A, B)
```

</details>

<details><summary><b>C++</b></summary>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (A == nullptr || B == nullptr) return false;

        return isSubTree(A, B)
            || isSubStructure(A->left, B) 
            || isSubStructure(A->right, B);
    }

    bool isSubTree(TreeNode* A, TreeNode* B) {
        if (B == nullptr) return true; 
        if (A == nullptr) return false;

        if (A->val == B->val) {
            return isSubTree(A->left, B->left) && isSubTree(A->right, B->right);
        } else {
            return false;
        }
    }
};
```

</details>

---

### `剑指Offer 2700 二叉树的镜像 (简单, 2021-11)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![递归](https://img.shields.io/badge/递归-lightgray.svg)](算法-递归、迭代.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树", "递归"],
    "来源": "剑指Offer",
    "编号": "2700",
    "难度": "简单",
    "标题": "二叉树的镜像"
}-->

<summary><b>问题简述</b></summary>

```txt
输入一个二叉树，输出它的镜像。
```

<details><summary><b>详细描述</b></summary>

```txt
请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9

镜像输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

示例 1：
    输入：root = [4,2,7,1,3,6,9]
    输出：[4,7,2,9,6,3,1]

限制：
    0 <= 节点个数 <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<!-- <div align="center"><img src="./_assets/xxx.png" height="300" /></div> -->

</details>


<summary><b>思路</b></summary>

- 对当前节点，镜像操作，就是调换左右子树，即 `left, right = right, left`；
- 对整个树镜像，就是将每个节点下的左右子树都调换；
- 具体操作：**先序或后序**遍历每个节点，然后交换该节点的左右子树；
- **为什么不可以中序遍历？**
    - 根据中序遍历的性质，当对根节点进行操作镜像时，其左子树已经完成了镜像，右子树还没有；
    - 此时交换左右子树，相当于把已经完成交换的左子树变成了右子树，之后在右子树上的镜像操作实际还是在对这个原来的左子树操作（相当于又把它还原了）；
    - 所以中序遍历的最终结果，就只是仅仅交换了根节点的左右子树；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:
        """"""
        if root is None: return None

        # 交换左右子树
        root.left, root.right = root.right, root.left

        # 递归应用到左右子树
        self.mirrorTree(root.left)
        self.mirrorTree(root.right)

        return root
```

</details>

---

### `剑指Offer 2800 对称的二叉树 (简单, 2021-11)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![递归](https://img.shields.io/badge/递归-lightgray.svg)](算法-递归、迭代.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树", "递归"],
    "来源": "剑指Offer",
    "编号": "2800",
    "难度": "简单",
    "标题": "对称的二叉树"
}-->

<summary><b>问题简述</b></summary>

```txt
判断一棵二叉树是不是对称的。
```
> [剑指 Offer 28. 对称的二叉树 - 力扣（LeetCode）](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

<details><summary><b>详细描述</b></summary>

```txt
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
 

示例 1：
    输入：root = [1,2,2,3,4,4,3]
    输出：true
示例 2：
    输入：root = [1,2,2,null,3,null,3]
    输出：false
 

限制：
    0 <= 节点个数 <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<!-- <div align="center"><img src="./_assets/xxx.png" height="300" /></div> -->

</details>


<summary><b>思路</b></summary>

- 想象一左一右两条路线，沿途比较路线上的节点，如果一路相等，同时达到叶子，说明这两条路线是相同的；
- “对称”则要求这两条路线必须从根节点的左右子节点开始；且沿途左路线往左的时候，右路线必须往右，来满足对称；
- 递归的中止条件必须考虑全面；

<div align="center"><img src="../_assets/图解对称的二叉树.png" height="200" /></div>

> [对称的二叉树（递归，清晰图解）](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/)

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True  # 空树返回 True

        def dfs(l, r):
            """"""
            # 如果能同时达到叶子节点，说明这两条路线是对称的
            if l is None and r is None: return True
            elif not r or not l: return False
            
            # 递归判断
            return l.val == r.val and dfs(l.left, r.right) and dfs(l.right, r.left)
        
        return dfs(root.left, root.right)

```

</details>

<details><summary><b>C++</b></summary>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) 
            return true;

        return dfs(root->left, root->right);
    }

    bool dfs(TreeNode* l, TreeNode* r) {  // 注意，出了根节点外，l 和 r 并不是同一节点的左右子树，理解这一点很重要
        if (l == nullptr && r == nullptr) 
            return true;
        if (l == nullptr || r == nullptr) 
            return false;
            
        if (l->val == r->val) {
            return dfs(l->left, r->right) && dfs(l->right, r->left);
        } else {
            return false;
        }

    }
};
```

</details>

---

### `剑指Offer 3201 层序遍历二叉树 (简单, 2021-11)`

[![BFS](https://img.shields.io/badge/BFS-lightgray.svg)](算法-广度优先搜索(BFS).md)
[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![队列](https://img.shields.io/badge/队列-lightgray.svg)](数据结构-栈、队列.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["BFS", "二叉树", "队列"],
    "来源": "剑指Offer",
    "编号": "3201",
    "难度": "简单",
    "标题": "层序遍历二叉树"
}-->

<summary><b>问题简述</b></summary>

```txt
层序遍历二叉树
```

<details><summary><b>详细描述</b></summary>

```txt
从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

例如:
    给定二叉树: [3,9,20,null,null,15,7],

        3
    / \
    9  20
        /  \
    15   7
返回：
    [3,9,20,15,7]
 
提示：
    节点总数 <= 1000


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<!-- <div align="center"><img src="./_assets/xxx.png" height="300" /></div> -->

</details>


<summary><b>思路</b></summary>

- 利用辅助队列 q；
    1. 将树的根结点入队；
    2. 如果 q 不为空，则将头结点出队记为 node；如果 node 的左节点不为空，则将左节点入队；如果 node 的右节点不为空，则将右节点入队；
    3. 重复 2、3，直到 q 为空


<details><summary><b>Python</b></summary>

- `list` 也可以模拟队列，为什么还要用 `collections.deque`？
    - `list.pop(0)` 的时间复杂度为 `O(N)`；而 `deque.popleft()` 只要 `O(1)`；

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[int]:
        from collections import deque

        if not root: return []

        buf = deque([root])  # 队列
        ret = []
        while buf:
            cur = buf.popleft()  # 弹出队列头
            ret.append(cur.val)

            if cur.left:
                buf.append(cur.left)
            if cur.right:
                buf.append(cur.right)
        
        return ret
```

</details>


<details><summary><b>C++</b></summary>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {

public:
    vector<int> levelOrder(TreeNode* root) {
        
        vector<int> ret;
        queue<TreeNode*> q;  // 辅助队列
        
        if (root)
            q.push(root);

        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();

            ret.push_back(node->val);
            if (node->left) {
                q.push(node->left);
            }
            if (node->right) {
                q.push(node->right);
            }
        }

        return ret;
    }
};
```

</details>

---

### `剑指Offer 3202 层序遍历二叉树 (简单, 2021-11)`

[![BFS](https://img.shields.io/badge/BFS-lightgray.svg)](算法-广度优先搜索(BFS).md)
[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![队列](https://img.shields.io/badge/队列-lightgray.svg)](数据结构-栈、队列.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["BFS", "二叉树", "队列"],
    "来源": "剑指Offer",
    "编号": "3202",
    "难度": "简单",
    "标题": "层序遍历二叉树"
}-->

<summary><b>问题简述</b></summary>

```txt
从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
```

<details><summary><b>详细描述</b></summary>

```txt
从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

例如:
    给定二叉树: [3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7
    返回其层次遍历结果：
    [
        [3],
        [9,20],
        [15,7]
    ]

提示：
    节点总数 <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 相比 “层序遍历二叉树-1”，本题需要同时记录当前层的节点数量（写法1）；
- 实际上每一层的节点数量包含在了保存的队列信息中，详见（写法2）；

<details><summary><b>Python：写法1</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        from collections import deque

        if not root: return []

        buf = deque([root])
        cnt = 1  # 记录当前层的节点数量
        ret = []
        while buf:
            tmp = []  # 记录层结果
            for _ in range(cnt):  # 循环当前层节点数量的次数，期间改变 cnt 不会影响遍历次数
                cur = buf.popleft()
                tmp.append(cur.val)
                cnt -= 1

                if cur.left:
                    buf.append(cur.left)
                    cnt += 1
                if cur.right:
                    buf.append(cur.right)
                    cnt += 1
            ret.append(tmp)

        return ret
```

</details>

<details><summary><b>Python：写法2</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        from collections import deque

        if not root: return []

        buf = deque([root])
        ret = []
        while buf:
            tmp = []
            for _ in range(len(buf)):
                cur = buf.popleft()
                tmp.append(cur.val)
                
                if cur.left:
                    buf.append(cur.left)
                if cur.right:
                    buf.append(cur.right)
            
            ret.append(tmp)
        
        return ret
```

</details>

---

### `剑指Offer 3203 层序遍历二叉树（之字形遍历） (简单, 2021-11)`

[![BFS](https://img.shields.io/badge/BFS-lightgray.svg)](算法-广度优先搜索(BFS).md)
[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![队列](https://img.shields.io/badge/队列-lightgray.svg)](数据结构-栈、队列.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["BFS", "二叉树", "队列"],
    "来源": "剑指Offer",
    "编号": "3203",
    "难度": "简单",
    "标题": "层序遍历二叉树（之字形遍历）"
}-->

<summary><b>问题简述</b></summary>

```txt
按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
```

<details><summary><b>详细描述</b></summary>

```txt
请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

例如:
    给定二叉树: [3,9,20,null,null,15,7],

        3
       / \
      9  20
        /  \
       15   7
    返回其层次遍历结果：

    [
        [3],
        [20,9],
        [15,7]
    ]

提示：
    节点总数 <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 在“层序遍历二叉树-2”的基础上，加入奇偶层的处理即可；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        from collections import deque

        if not root: return []

        buf = deque([root])
        lv = 1  # 记录当前层数
        cnt = 1  # 记录当前层的节点数
        ret = []
        while buf:
            tmp = []
            for _ in range(cnt):
                cur = buf.popleft()
                tmp.append(cur.val)
                cnt -= 1

                if cur.left:
                    buf.append(cur.left)
                    cnt += 1
                if cur.right:
                    buf.append(cur.right)
                    cnt += 1
            
            # 上面的代码跟 层序遍历二叉树-2 完全相同，
            # 在将 tmp 加入 ret 时，对偶数层的 tmp 做一下倒序
            if lv & 1:  # 奇数层
                ret.append(tmp)
            else:
                ret.append(tmp[::-1])
            lv += 1
        
        return ret
```

</details>

---

### `剑指Offer 3300 二叉搜索树的后序遍历序列 (中等, 2021-12)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树"],
    "来源": "剑指Offer",
    "编号": "3300",
    "难度": "中等",
    "标题": "二叉搜索树的后序遍历序列"
}-->

<summary><b>问题简述</b></summary>

```txt
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。
```

<details><summary><b>详细描述</b></summary>

```txt
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3

示例 1：
    输入: [1,6,3,2,5]
    输出: false
示例 2：
    输入: [1,3,2,6,5]
    输出: true

提示：
    数组长度 <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 记后序遍历的结果为 `p`，则 `p` 有如下结论：
    - `p[-1]` 为根节点：
    - `p[:-1]` 可以划分为左右子树两个部分，分别记为 `pl` 和 `pr`；
- 而该二叉树为二叉搜索树，又有 `all(x < p[-1] for x in pl)` 和 `all(x > p[-1] for x in pr)`
- 然后递归判断左右子树是否满足以上性质即可；

<details><summary><b>Python</b></summary>

```python
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:

        def dfs(p):
            if not p: return True  # 记空树为二叉搜索树

            root_val = p[-1]
            pl = []  # 左子树
            for idx, x in enumerate(p):
                if x < root_val:  # 题目规定 p 中元素互不相等
                    pl.append(x)
                else:
                    break
            
            pr = p[idx: -1]  # 右子树
            flag = all(x > root_val for x in pr)
            return flag and dfs(pl) and dfs(pr)

        return dfs(postorder)
```

</details>

<details><summary><b>Python：优化</b></summary>

- 可以用索引范围代替 `pl` 和 `pr`，避免使用额外空间；
- 还有其他判断方法，这里是严格按照上面的思路来写的；
    > [二叉搜索树的后序遍历序列（递归分治 / 单调栈，清晰图解）](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/)

```python
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        p = postorder

        def dfs(l, r):  # [l, r]
            if l >= r: return True

            root_val = p[r]
            cnt = 0  # 记录小于root的节点数量，即左子树
            for i in range(l, r):  # 这里踩了个坑，不能直接用 i 代替 cnt，因为退出循环时不能保证 i 一定指向第一个大于 root 的元素，比如右子树为空的情况
                if p[i] > root_val:
                    break
                else:
                    cnt += 1
            flag = all(p[i] > root_val for i in range(l + cnt, r))
            return flag and dfs(l, l + cnt - 1) and dfs(l + cnt, r - 1)

        return dfs(0, len(p) - 1)
```

</details>

---

### `剑指Offer 3400 二叉树中和为某一值的路径 (中等, 2021-12)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "剑指Offer",
    "编号": "3400",
    "难度": "中等",
    "标题": "二叉树中和为某一值的路径"
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和一个整数 targetSum ，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。
```

<details><summary><b>详细描述</b></summary>

```txt
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

示例 1：
    输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
    输出：[[5,4,11,2],[5,8,4,5]]
示例 2：
    输入：root = [1,2,3], targetSum = 5
    输出：[]
示例 3：
    输入：root = [1,2], targetSum = 0
    输出：[]

提示：
    树中节点总数在范围 [0, 5000] 内
    -1000 <= Node.val <= 1000
    -1000 <= targetSum <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 先序深度优先搜索；
- 因为要保存路径，所以还要加上回溯序列；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def pathSum(self, root: TreeNode, target: int) -> List[List[int]]:
        if not root: return []

        ret = []
        buf = []
        def dfs(R, T):
            # 这样写会导致结果输出两次，原因是如果当前叶节点满足后，会继续遍历其左右两个空节点，导致结果被添加两次
            # if not R:
            #     if T == 0:
            #         ret.append(buf[:])
            #     return

            if not R: return
            if R.left is None and R.right is None:
                if T == R.val:
                    ret.append(buf[:] + [R.val])  # 直接传 buf 会有问题，而 buf[:] 相对于 buf 的一份浅拷贝
                return

            buf.append(R.val)
            dfs(R.left, T - R.val)
            dfs(R.right, T - R.val)
            buf.pop()
        
        dfs(root, target)
        return ret
```

</details>

---

### `剑指Offer 3600 二叉搜索树与双向链表 (中等, 2021-12)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![递归](https://img.shields.io/badge/递归-lightgray.svg)](算法-递归、迭代.md)
[![经典](https://img.shields.io/badge/经典-lightgray.svg)](基础-经典问题&代码.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树", "递归", "经典"],
    "来源": "剑指Offer",
    "编号": "3600",
    "难度": "中等",
    "标题": "二叉搜索树与双向链表"
}-->

<summary><b>问题简述</b></summary>

```txt
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。
```

<details><summary><b>详细描述</b></summary>

```txt
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

为了让您更好地理解问题，以下面的二叉搜索树为例：

     4
    / \
   2   5
  / \
 1   3

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

 head -> 1 <-> 2 <-> 3 <-> 4 <-> 5 (1 和 5 也互连)
         ↑-----------------------↑

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 根据二叉搜索树的性质，其**中序遍历**结果就是一个有序的单向链表；
- 因此本题要做的就是在中序遍历的过程中，修改指针的指向，得到双向链表；
- 考虑使用中序遍历访问树的各节点，记 `cur`，初始化前驱节点 `pre=None`；  
  1. 在访问每个节点时构建 `cur` 和前驱节点 `pre` 的引用指向；  
  2. 当 `pre=None` 时，说明该节点是最左叶子节点（中序遍历访问的第一个节点），即头结点 `ret`；否则修改双向节点引用，即 `pre.right = cur`， `cur.left = pre`；
  3. **在访问右子树前，将 `pre` 指向 `cur`；**
  4. 中序遍历完成后，最后构建头节点和尾节点的引用指向。  

<details><summary><b>Python</b></summary>

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return None

        self.ret = self.pre = None

        def dfs(cur):
            if not cur:
                return

            dfs(cur.left)
            if self.pre:
                self.pre.right = cur
                cur.left = self.pre
            else:  # 达到最左叶子节点（只执行一次）
                self.ret = cur  # 双向链表的头结点
            
            self.pre = cur  # 在遍历右子树前，将 pre 指向 cur
            dfs(cur.right)

        dfs(root)
        # 遍历结束时，pre 指向最右叶子节点
        self.ret.left = self.pre 
        self.pre.right = self.ret
        return self.ret
```

</details>

---

### `剑指Offer 3700 序列化二叉树 (困难, 2021-12)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树"],
    "来源": "剑指Offer",
    "编号": "3700",
    "难度": "困难",
    "标题": "序列化二叉树"
}-->

<summary><b>问题简述</b></summary>

```txt
实现两个函数，分别用来序列化和反序列化二叉树。
```

<details><summary><b>详细描述</b></summary>

```txt
请实现两个函数，分别用来序列化和反序列化二叉树。

你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

示例：
    输入：root = [1,2,3,null,null,4,5]
    输出：[1,2,3,null,null,4,5]

注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

~~<summary><b>思路1：中序遍历+前序/后序遍历</b></summary>~~

- **只适用于树种节点不重复的情况**；
- 单独的中序/前序/后序能不能还原二叉树；
- 但是中序 + 前序/后序就可以；
- 因此可以序列化可以输出，中序+前序/后序的结果，反序列化时再用他们还原；

<details><summary><b>Python</b></summary>

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """

        inorder = []
        preorder = []

        def in_dfs(r):
            if not r: return

            in_dfs(r.left)
            inorder.append(r.val)
            in_dfs(r.right)

        def pre_dfs(r):
            if not r: return

            preorder.append(r.val)
            pre_dfs(r.left)
            pre_dfs(r.right)

        in_dfs(root)
        pre_dfs(root)
        return str(inorder) + ', ' + str(preorder)

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        inorder, preorder = eval(data)

        def dfs(inorder, preorder):
            if not inorder and not preorder: return

            root_val = preorder[0]
            root = TreeNode(root_val)
            root_idx = inorder.index(root_val)

            root.left = dfs(inorder[:root_idx], preorder[1:root_idx + 1])
            root.right = dfs(inorder[root_idx + 1:], preorder[root_idx + 1:])
            
            return root
        
        return dfs(inorder, preorder)

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
```

</details>


<summary><b>思路2：层序遍历</b></summary>

- 无论是序列化还是反序列化，都需要用到辅助队列；
- 层序遍历的缺点是可能会保存很多无效的空节点；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        from collections import deque

        if not root: return '[]'  # 空判断

        buf = deque([root])
        ret = []
        while buf:
            p = buf.popleft()
            if p:
                ret.append(p.val)
                buf.append(p.left)
                buf.append(p.right)
            else:  # 注意空节点也要保存
                ret.append(None)

        return str(ret)

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        from collections import deque

        data = eval(data)  # 利用 python 的 eval 函数方便的将字符串还原为列表
        if not data: return None  # 空判断

        i = 0  # 记录当前节点在 data 中的位置
        root = TreeNode(data[i])
        i += 1
        buf = deque([root])

        while buf:
            p = buf.popleft()
            if data[i] is not None:  # 因为在 if 中 0 也是 False，所以保险起见用 is not None 来判断
                p.left = TreeNode(data[i])
                buf.append(p.left)  # 新节点入队，当生成下一层的节点时，依然按照从左往右的顺序
            i += 1
            if data[i] is not None:
                p.right = TreeNode(data[i])
                buf.append(p.right)
            i += 1

        return root


# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
```

</details>

---

### `剑指Offer 5400 二叉搜索树的第k大节点 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![dfs](https://img.shields.io/badge/dfs-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树", "dfs"],
    "来源": "剑指Offer",
    "编号": "5400",
    "难度": "简单",
    "标题": "二叉搜索树的第k大节点"
}-->

<summary><b>问题简述</b></summary>

```txt
给定一棵二叉搜索树，请找出其中第 k 大的节点的值。
```

<details><summary><b>详细描述</b></summary>

```txt
给定一棵二叉搜索树，请找出其中第 k 大的节点的值。

示例 1:
    输入: root = [3,1,4,null,2], k = 1
       3
      / \
     1   4
      \
       2
    输出: 4
示例 2:
    输入: root = [5,3,6,2,4,null,null,1], k = 3
           5
          / \
         3   6
        / \
       2   4
      /
     1
    输出: 4

限制：
    1 ≤ k ≤ 二叉搜索树元素个数

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<!-- <div align="center"><img src="./_assets/xxx.png" height="300" /></div> -->

</details>


<summary><b>思路</b></summary>

- 根据二叉搜索树的性质，其中序遍历的结果为递增序列；
- 为了得到第 k 大的数，需要递减序列，“反向”中序遍历即可：即按“右中左”的顺序深度搜索（正向为“左中右”）；
- 利用辅助变量提前结束搜索；


<details><summary><b>C++</b></summary>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int k;
    int ret;

    void inOrder(TreeNode* node) {
        if (node == nullptr) return;

        inOrder(node->right);  // 先遍历右子树
        if (--this->k == 0) {  // 因为 k>0，实际上第 1 大指的是索引为 0 的位置，所以要先 --
            this->ret = node->val;
            return;
        }
        inOrder(node->left);
    }
    
public:
    int kthLargest(TreeNode* root, int k) {
        this->k = k;
        inOrder(root);
        return this->ret;
    }
};
```

</details>

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:

        self.cnt = 0
        self.ret = -1
        
        def dfs(node):
            if node is None:
                return 
            
            dfs(node.right)
            self.cnt += 1
            if self.cnt == k:
                self.ret = node.val
                return 
            dfs(node.left)
        
        dfs(root)
        return self.ret
```

</details>

---

### `剑指Offer 5501 求二叉树的深度 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树"],
    "来源": "剑指Offer",
    "编号": "5501",
    "难度": "简单",
    "标题": "求二叉树的深度"
}-->

<summary><b>问题简述</b></summary>

```txt
输入一棵二叉树的根节点，求该树的深度。
```

<details><summary><b>详细描述</b></summary>

```txt
输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

例如：
    给定二叉树 [3,9,20,null,null,15,7]，
    
        3
       / \
      9  20
        /  \
       15   7
    返回它的最大深度 3 。

提示：
    节点总数 <= 10000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

<!-- <div align="center"><img src="./_assets/xxx.png" height="300" /></div> -->

</details>


<summary><b>思路</b></summary>

- 递归公式：`最大深度 := 1 + 子树的最大深度`


<details><summary><b>C++</b></summary>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;

        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
```

</details>


<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -> int:

        def dfs(node):
            if node is None:
                return 0

            return 1 + max(dfs(node.left), dfs(node.right))

        # def dfs(node):  # 可以看做是一个后序遍历的过程
        #     if node is None:
        #         return 0
            
        #     lh = dfs(node.left)
        #     # ...
        #     rh = dfs(node.right)
        #     # ...
        #     return 1 + max(lh, rh)

        return dfs(root)
```

</details>

---

### `剑指Offer 5502 判断是否为平衡二叉树 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树"],
    "来源": "剑指Offer",
    "编号": "5502",
    "难度": "简单",
    "标题": "判断是否为平衡二叉树"
}-->

<summary><b>问题简述</b></summary>

```txt
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。
```

<details><summary><b>详细描述</b></summary>

```txt
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

示例 1:
    给定二叉树 [3,9,20,null,null,15,7]

        3
       / \
      9  20
        /  \
       15   7
    返回 true 。

示例 2:
    给定二叉树 [1,2,2,3,3,null,null,4,4]

           1
          / \
         2   2
        / \
       3   3
      / \
     4   4
    返回 false 。

限制：
    0 <= 树的结点个数 <= 10000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1: 先序遍历，自顶向下（次优解）</b></summary>

- 设计一个求树高度的子函数；
- 如果左右子树的高度差 <= 1 则返回 True；然后递归遍历左右子树；
- 存在大量重复计算，时间复杂度 `O(NlogN)`

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:

        def depth(node):
            if node is None:
                return 0
            return 1 + max(depth(node.left), depth(node.right))
        
        def dfs(node):
            if node is None:
                return True
            
            return abs(depth(node.left) - depth(node.right)) <= 1 \
                and dfs(node.left) \
                and dfs(node.right)
            
        return dfs(root)
```

</details>

<summary><b>思路2: 后序遍历，自底向上（最优解）</b></summary>

> [平衡二叉树（从底至顶、从顶至底，清晰图解）](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/solution/mian-shi-ti-55-ii-ping-heng-er-cha-shu-cong-di-zhi/)

<details><summary><b>Python</b></summary>

- 可以在求二叉树深度的过程中，提前判断是否为平衡二叉树，若不是则提前结束（剪枝）；
- 时间复杂度：`O(N)`；

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:

        def dfs(node):
            if node is None:
                return 0

            lh = dfs(node.left)  # 左子树的高度
            if lh == -1:
                return -1

            rh = dfs(node.right)  # 右子树的高度
            if rh == -1:
                return -1

            if abs(lh - rh) <= 1:
                return 1 + max(lh, rh) + 1
            else:
                return -1

        return dfs(root) != -1
```

</details>

---

### `剑指Offer 6802 二叉树的最近公共祖先 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![TreeDP](https://img.shields.io/badge/TreeDP-lightgray.svg)](技巧-自底向上的递归技巧.md)
[![剑指Offer](https://img.shields.io/badge/剑指Offer-lightgray.svg)](合集-剑指Offer.md)

<!--{
    "tags": ["二叉树", "TreeDP"],
    "来源": "剑指Offer",
    "编号": "6802",
    "难度": "简单",
    "标题": "二叉树的最近公共祖先"
}-->

<summary><b>问题简述</b></summary>

```txt
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
```
> [剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

<details><summary><b>详细描述</b></summary>

```txt
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树

            3
          /   \
         5     1
        / \   / \
       6   2 0   8
          / \
         7   4

示例 1:
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    输出: 3
    解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    输出: 5
    解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

说明:
    所有节点的值都是唯一的。
    p、q 为不同节点且均存在于给定的二叉树中。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1</b></summary>

- 记录 p, q 从上到下的路径，路径中最后一个相同节点即答案；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:

        # 后序遍历记录所有祖先
        def dfs(node, target, trace):
            if node is None:
                return False
            
            # 注意自己也是自己的祖先
            if node.val == target.val or dfs(node.left, target, trace) or dfs(node.right, target, trace):
                trace.append(node)
                return True
            else:
                return False
        
        # 分别找出 p 和 q 的祖先路径
        trace_p = []
        dfs(root, p, trace_p)
        # print(trace_p)
        trace_q = []
        dfs(root, q, trace_q)
        # print(trace_q)

        # 遍历找出最后一个相同的祖先
        ret = None
        for l, r in zip(trace_p[::-1], trace_q[::-1]):
            if l.val == r.val:
                ret = l
            else:
                break
        
        return ret
```

</details>


<summary><b>思路2</b></summary>

- 考虑判断节点 x 是否为 p、q 的最近祖先需要哪些信息：
- 文字描述太繁琐，直接看代码，非常清晰；

<details><summary><b>Python</b></summary>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        
        from dataclasses import dataclass

        @dataclass
        class Info:  # 判断当前节点是否为答案需要从子节点了解到的信息
            has_p: bool
            has_q: bool
            ret: TreeNode
        
        def dfs(x):
            if not x: return Info(False, False, None)

            # l, r = dfs(x.left), dfs(x.right)
            # 提前结束
            l = dfs(x.left)
            if l.ret: return l
            r = dfs(x.right)
            if r.ret: return r

            has_p = x.val == p.val or l.has_p or r.has_p
            has_q = x.val == q.val or l.has_q or r.has_q
            ret = None

            if has_p and has_q:
                ret = l.ret if r.ret is None else r.ret  # 左右子节点
                ret = x if ret is None else ret  # x 节点才是
            
            return Info(has_p, has_q, ret)
        
        return dfs(root).ret
```

</details>

---

### `牛客 0005 二叉树根节点到叶子节点的所有路径和 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0005",
    "标题": "二叉树根节点到叶子节点的所有路径和",
    "公司": ["小米", "快手", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树，求所有路径和，路径定义如下：
假设某条路径的从根节点到叶节点的值为 1->2->3，则记该条路径表示的值为 123；
输入确保每个节点的值在 0~9 之间；

示例
    1
   2 3
结果：25（12+13=25）
```
> [二叉树根节点到叶子节点的所有路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/185a87cd29eb42049132aed873273e83)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def sumNumbers(self , root: TreeNode) -> int:
        # write code here
        
        self.ret = 0
        
        def dfs(node: TreeNode, sum_):
            if not node:
                # self.ret += sum_  # 放在这里会导致“加两次”
                return
            
            sum_ = sum_ * 10 + node.val
            if not node.left and not node.right:
                self.ret += sum_
                return
            
            if node.left:
                dfs(node.left, sum_)
            if node.right:
                dfs(node.right, sum_)
        
        dfs(root, 0)
        return self.ret
```

</details>

---

### `牛客 0006 二叉树中的最大路径和 (较难, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "较难",
    "编号": "0006",
    "标题": "二叉树中的最大路径和",
    "公司": ["字节", "美团", "百度"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定二叉树中的最大路径和。
路径定义：
    1. 同一个节点在路径中最多出现一次；
    2. 路径至少包含一个节点，可以不经过根节点；
```
> [二叉树中的最大路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

- 定义函数 `maxGain(node)` 表示以 `node` 为**起点**的最大路径；显然 maxGain 可以通过递归计算（详见代码）；
- 则**经过** `node` 的最大路径和，可以表示为 `node.val + maxGain(node.left), maxGain(node.right)`；因此可以在计算 `maxGain(root)` 的过程中，记录经过每个节点的最大路径和，进而得到全局最大路径。

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        # write code here

        self.ret = float('-inf')

        def maxGain(node):
            if not node: return 0

            # 如果子路径的 maxGain 为负数，那么对 node 来说 maxGain 就是自己本身；
            max_left = max(0, maxGain(node.left))
            max_right = max(0, maxGain(node.right))
            # 记录“经过”node 节点的最大路径
            self.ret = max(self.ret, node.val + max_left + max_right)
            return node.val + max(max_left, max_right)  # 至少要包含自己本身

        maxGain(root)
        return self.ret
```

</details>

---

### `牛客 0008 二叉树中和为某一值的路径(二) (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0008",
    "标题": "二叉树中和为某一值的路径(二)",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和目标值 target，返回所有和为 target 的路径。
规定路径必须从根节点开始到叶子节点。
```
> [二叉树中和为某一值的路径(二)_牛客题霸_牛客网](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param target int整型 
# @return int整型二维数组
#
class Solution:
    def FindPath(self , root: TreeNode, target: int) -> List[List[int]]:
        # write code here
        
        ret = []
        tmp = []
        
        def dfs(node, k):
            if not node: return
            
            tmp.append(node.val)
            k -= node.val
            
            if not node.left and not node.right and k == 0:
                ret.append(tmp[:])
            
            dfs(node.left, k)
            dfs(node.right, k)
            k += node.val
            tmp.pop()
        
        dfs(root, target)
        return ret
```

</details>

---

### `牛客 0009 二叉树中和为某一值的路径(一) (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0009",
    "标题": "二叉树中和为某一值的路径(一)",
    "公司": ["腾讯", "字节", "京东"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和目标值 target，判断是否存在路径和等于 target。
规定路径必须从根节点开始到叶子节点。
```
> [二叉树中和为某一值的路径(一)_牛客题霸_牛客网](https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return bool布尔型
#
class Solution:
    def hasPathSum(self , root: TreeNode, sum: int) -> bool:
        # write code here
        
        def dfs(node, k):
            if not node: return False
            
            if k == node.val and not node.left and not node.right:
                return True
            
            return dfs(node.left, k - node.val) or dfs(node.right, k - node.val)
        
        return dfs(root, sum)
```

</details>

---

### `牛客 0011 将升序数组转化为平衡二叉搜索树 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0011",
    "标题": "将升序数组转化为平衡二叉搜索树",
    "公司": ["百度", "映客"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定升序数组，转化为平衡二叉搜索树（BST）
```
> [将升序数组转化为平衡二叉搜索树_牛客题霸_牛客网](https://www.nowcoder.com/practice/7e5b00f94b254da599a9472fe5ab283d)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 每次选择中间节点作为根节点，按先序遍历递归构建 BST；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @return TreeNode类
#
class Solution:
    def sortedArrayToBST(self , num: List[int]) -> TreeNode:
        # write code here
        def dfs(arr):
            if not arr: return None
            
            l, r = 0, len(arr) - 1
            mid = (l + r) // 2
            
            node = TreeNode(arr[mid])
            node.left = dfs(arr[:mid])
            node.right = dfs(arr[mid + 1:])
            
            return node
        
        return dfs(num)
```

</details>

---

### `牛客 0012 重建二叉树 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0012",
    "标题": "重建二叉树",
    "公司": ["小米", "携程", "腾讯", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树的前序和中序遍历结果，重建二叉树；
规定二叉树中各节点的值都不相同；
```
> [重建二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 前序遍历的第一个节点为根节点，在中序遍历中找到根节点的位置，其左边部分为左子树，右边为右子树，然后按前序遍历递归构建整个树；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pre int整型一维数组 
# @param vin int整型一维数组 
# @return TreeNode类
#
class Solution:
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        # write code here
        
        def dfs(p, i):
            if not p or not i: return None
            
            val = p[0]
            idx = i.index(val)
            node = TreeNode(val)
            
            node.left = dfs(p[1:idx + 1], i[:idx])
            node.right = dfs(p[idx + 1:], i[idx + 1:])
            
            return node
        
        return dfs(pre, vin)
```

</details>

---

### `牛客 0013 二叉树的最大深度 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0013",
    "标题": "二叉树的最大深度",
    "公司": ["字节", "小米", "阿里"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定二叉树的最大深度。
```
> http://

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxDepth(self , root: TreeNode) -> int:
        # write code here
        
        def dfs(node):
            if not node: return 0
            
            return 1 + max(dfs(node.left), dfs(node.right))
        
        return dfs(root)
```

</details>

---

### `牛客 0014 按之字形顺序打印二叉树 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![队列](https://img.shields.io/badge/队列-lightgray.svg)](数据结构-栈、队列.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树", "队列"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0014",
    "标题": "按之字形顺序打印二叉树",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
层序遍历二叉树，按之字形打印每层。
```
> [按之字形顺序打印二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 队列 + 奇偶讨论，思路比较简单，因为需要把层分离，所以需要借助的辅助变量比较多，详见代码；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return int整型二维数组
#
class Solution:
    def Print(self , pRoot: TreeNode) -> List[List[int]]:
        # write code here
        if not pRoot: return []
        
        from collections import deque
        
        ret = []
        q = deque()
        q.append(pRoot)
        cnt = 1
        nxt = 0  # 下一层需要遍历的节点数
        lv = 0  # 已经遍历的层数
        tmp = []  # 当前层缓存的节点数
        while cnt:
            cnt -= 1
            node = q.popleft()
            tmp.append(node.val)
            
            if node.left:
                q.append(node.left)
                nxt += 1
            if node.right:
                q.append(node.right)
                nxt += 1
            
            if cnt == 0:
                if lv % 2:
                    ret.append(tmp[::-1])
                else:
                    ret.append(tmp)
                tmp = []
                lv += 1
                cnt = nxt
                nxt = 0
                
        return ret
```

</details>

---

### `牛客 0015 求二叉树的层序遍历 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0015",
    "标题": "求二叉树的层序遍历",
    "公司": ["腾讯", "美团", "小米", "神策数据"]
}-->

<summary><b>问题简述</b></summary>

```txt
层序遍历二叉树，每层的结果单独保存在一个列表中。
```
> [求二叉树的层序遍历_牛客题霸_牛客网](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 辅助队列

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型二维数组
#
class Solution:
    def levelOrder(self , root: TreeNode) -> List[List[int]]:
        # write code here
        if not root: return []
        
        from collections import deque
        
        ret = []
        q = deque()
        q.append(root)
        cnt = 1
        nxt = 0
        tmp = []
        while cnt:
            cnt -= 1
            node = q.popleft()
            tmp.append(node.val)
            
            if node.left:
                q.append(node.left)
                nxt += 1
            if node.right:
                q.append(node.right)
                nxt += 1
                
            if cnt == 0:
                ret.append(tmp)
                tmp = []
                cnt = nxt
                nxt = 0
        
        return ret
```

</details>

---

### `牛客 0016 对称的二叉树 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0016",
    "标题": "对称的二叉树",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
判断给定二叉树是否对称。
```
> [对称的二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 跟一般的二叉树递归略有不同，因为对称的二叉树，其子树并不对称；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    def isSymmetrical(self , pRoot: TreeNode) -> bool:
        # write code here
        if not pRoot: return True
        
        def dfs(l, r):
            if not l and not r: return True  # 同时到达叶节点
            if not l or not r: return False
            
            return l.val == r.val and dfs(l.left, r.right) and dfs(l.right, r.left)
            
        return dfs(pRoot.left, pRoot.right)
```

</details>

---
