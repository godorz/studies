# 递归

<!-- Tag: 回溯 -->

Problems
---
- [`牛客 0026 括号生成 (中等, 2022-02)`](#牛客-0026-括号生成-中等-2022-02)
- [`牛客 0027 集合的所有子集(一) (中等, 2022-02)`](#牛客-0027-集合的所有子集一-中等-2022-02)
- [`牛客 0042 有重复项数字的全排列 (中等, 2022-03)`](#牛客-0042-有重复项数字的全排列-中等-2022-03)
- [`牛客 0043 没有重复项数字的全排列 (中等, 2022-03)`](#牛客-0043-没有重复项数字的全排列-中等-2022-03)

---

### `牛客 0026 括号生成 (中等, 2022-02)`

[![回溯](https://img.shields.io/badge/回溯-lightgray.svg)](算法-递归-回溯.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["回溯"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0026",
    "标题": "括号生成",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。
例如，给出n=3，解集为：
"((()))", "(()())", "(())()", "()()()", "()(())"
```
> [括号生成_牛客题霸_牛客网](https://www.nowcoder.com/practice/c9addb265cdf4cdd92c092c655d164ca)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：递归+回溯</b></summary>

- 关键是中止条件的判断，详见代码；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 
# @return string字符串一维数组
#
class Solution:
    def generateParenthesis(self , n: int) -> List[str]:
        # write code here
        
        ret = []
        tmp = []
        
        def dfs(i, j):
            if i > n or j > n or i < j:
                return
            
            if i == j == n:
                ret.append(''.join(tmp))
                return
            
            tmp.append('(')
            dfs(i + 1, j)
            tmp.pop()
            
            tmp.append(')')
            dfs(i, j + 1)
            tmp.pop()
        
        dfs(0, 0)
        return ret
```

</details>

---

### `牛客 0027 集合的所有子集(一) (中等, 2022-02)`

[![回溯](https://img.shields.io/badge/回溯-lightgray.svg)](算法-递归-回溯.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["回溯"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0027",
    "标题": "集合的所有子集(一)",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
现在有一个没有重复元素的整数集合S，求S的所有子集
注意：
    你给出的子集中的元素必须按升序排列
    给出的解集中不能出现重复的元素
```
> [集合的所有子集(一)_牛客题霸_牛客网](https://www.nowcoder.com/practice/c333d551eb6243e0b4d92e37a06fbfc9)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：递归+回溯（01背包）</b></summary>

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param S int整型一维数组 
# @return int整型二维数组
#
class Solution:
    def subsets(self , S: List[int]) -> List[List[int]]:
        # write code here
        
        N = len(S)
        ret = []
        tmp = []
        
        def dfs(i):
            if i == N:
                ret.append(tmp[:])
                return
            
            # 不要当前元素
            dfs(i + 1)
            
            # 要当前元素
            tmp.append(S[i])
            dfs(i + 1)
            tmp.pop()
        
        dfs(0)
        return ret
```

</details>

---

### `牛客 0042 有重复项数字的全排列 (中等, 2022-03)`

[![回溯](https://img.shields.io/badge/回溯-lightgray.svg)](算法-递归-回溯.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["回溯"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0042",
    "标题": "有重复项数字的全排列",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。
```
> [有重复项数字的全排列_牛客题霸_牛客网](https://www.nowcoder.com/practice/a43a2b986ef34843ac4fdd9159b69863)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS+回溯</b></summary>

- 难点是重复数字的剪枝；
- 定义 `book[i] = 1` 表示 `num[i]` 已经使用过；
    > [全排列II - 代码随想录](https://www.programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html)

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
# 
# @param num int整型一维数组 
# @return int整型二维数组
#
class Solution:
    def permuteUnique(self , num: List[int]) -> List[List[int]]:
        
        ret = []
        tmp = []
        N = len(num)
        
        num.sort()  # 排序
        book = [0] * N
        
        def dfs(deep):
            if deep == N:
                ret.append(tmp[:])
                return 
            
            for i in range(N):
                if book[i]:
                    continue
                
                # 树层剪枝
                if not book[i - 1] and i > 0 and num[i] == num[i - 1]:
                    continue
                # 为什么是 not book[i - 1]？
                #   当遍历完一条路径回到本层的时候，book[i - 1] 会回溯为 0，
                #   此时如果还有 num[i] == num[i - 1]，说明当前路径重复，直接跳过
                
                book[i] = 1
                tmp.append(num[i])
                dfs(deep + 1)
                tmp.pop()
                book[i] = 0
        
        dfs(0)
        return ret
```

</details>

---

### `牛客 0043 没有重复项数字的全排列 (中等, 2022-03)`

[![回溯](https://img.shields.io/badge/回溯-lightgray.svg)](算法-递归-回溯.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](合集-牛客.md)

<!--{
    "tags": ["回溯"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0043",
    "标题": "没有重复项数字的全排列",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给出一组数字，返回该组数字的所有排列
例如：
[1,2,3]的所有排列如下
[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].
（以数字在数组中的位置靠前为优先级，按字典序排列输出。）
```
> [没有重复项数字的全排列_牛客题霸_牛客网](https://www.nowcoder.com/practice/4bcf3081067a4d028f95acee3ddcd2b1)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS+回溯</b></summary>

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @return int整型二维数组
#
class Solution:
    def permute(self , num: List[int]) -> List[List[int]]:
        
        ret = []
        tmp = []
        N = len(num)
        book = [0] * N
        
        def dfs(deep):
            if deep == N:
                ret.append(tmp[:])
            
            for i in range(N):
                if book[i]:
                    continue
                
                book[i] = 1
                tmp.append(num[i])
                dfs(deep + 1)
                tmp.pop()
                book[i] = 0
        
        dfs(0)
        return ret
```

</details>

---
